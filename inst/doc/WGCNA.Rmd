---
title: "WGCNA"
author: Yangming si
date: "`r format(Sys.time())`"
output:
  html_document:
    toc: true
    toc_depth: 3
    theme: cosmo
    code_folding: hide
  rmarkdown::html_vignette:
    keep_md: true
vignette: >
  %\VignetteIndexEntry{WGCNA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r options, echo=FALSE, message=FALSE}
library(rmarkdown)
library(knitr)
options(replace.assign = TRUE, width = 90)
opts_chunk$set(dev = c("png"), fig.width = 5, fig.height = 5, out.width = "800px", fig.align = "center", fig.pos = "htbp", fig.retina = FALSE, dev.args = list(pointsize = 11), cache = FALSE, dpi = 600)
```

```r
library(WGCNA)
# R版本低于4.0启用
# options(stringsAsFactors = FALSE)
enableWGCNAThreads()
library(anRichment)
library(cluster)
library(flashClust)
library(tidyverse)
```

``` r
source("https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/GeneAnnotation/installAnRichment.R")
installAnRichment()

install.packages("https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/GeneAnnotation/anRichment_1.10-1.tar.gz", repos = NULL, type = "source")
```

# 示例数据

利用RNA-Seq数据构建共表达网络

-   Alternative isoform regulation in human tissue transcriptomes <https://www.nature.com/articles/nature07509>

-   <https://www.ncbi.nlm.nih.gov//geo/query/acc.cgi?acc=GSE12946>

-   Expression profile of ectopic olfactory receptors determined by deep sequencing. <https://europepmc.org/article/pmc/pmc3566163>

# 学习资料

-   <https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/>

-   <https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/>

-   <https://cran.r-project.org/web/packages/WGCNA/index.html>

-   <https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/GeneAnnotation/>

-   <https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/index.html>

# 母鼠肝脏表达数据：与体重相关模块

<https://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.0020130>

![overview-femaleLiver.png](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/overview-femaleLiver.png)

## 数据输入和清理

```r
data("femData", package = "StatPlotR")
datExpr0 <- femData %>%
  select(-names(femData)[1:8]) %>%
  t() %>%
  as.data.frame()
names(datExpr0) <- femData$substanceBXH

gsg <- goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK

if (!gsg$allOK) {
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes) > 0) {
    printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")))
  }
  if (sum(!gsg$goodSamples) > 0) {
    printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")))
  }
  # Remove the offending genes and samples from the data:
  datExpr0 <- datExpr0[gsg$goodSamples, gsg$goodGenes]
}
```

## 样本聚类

```r
sampleTree <- hclust(dist(datExpr0), method = "average")
# flashClust=hclust
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(24, 9)
# pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6)
par(mar = c(0, 4, 2, 0))
plot(sampleTree,
  main = "Sample clustering to detect outliers", sub = "", xlab = "", cex.lab = 1.5,
  cex.axis = 1.5, cex.main = 2
)
# Plot a line to show the cut
abline(h = 15, col = "red")
```

```r
# Determine cluster under the line
clust <- cutreeStatic(sampleTree, cutHeight = 15, minSize = 10)
table(clust)

keepSamples <- (clust == 1)
datExpr <- datExpr0[keepSamples, ]
nGenes <- ncol(datExpr)
nSamples <- nrow(datExpr)
```

```r
data("allTraits", package = "StatPlotR")

femaleSamples <- rownames(datExpr)
traitRows <- match(femaleSamples, allTraits$Mice)
datTraits <- allTraits[traitRows, -1]
rownames(datTraits) <- allTraits$Mice[traitRows]
collectGarbage()
```

## 样本聚类和临床信息展示

```r
# Re-cluster samples
sampleTree2 <- hclust(dist(datExpr), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors <- numbers2colors(datTraits, signed = FALSE)
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
  groupLabels = names(datTraits),
  main = "Sample dendrogram and trait heatmap"
)
```

```r
save(datExpr, datTraits, file = "../examples/WGCNA/FemaleLiver-01-dataInput.RData")
```

## 选择软阈值

```r
load(file = "../examples/WGCNA/FemaleLiver-01-dataInput.RData")
# Choose a set of soft-thresholding powers
powers <- c(c(1:10), seq(from = 12, to = 20, by = 2))
# Call the network topology analysis function
sft <- pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
```

```r
# Plot the results:
sizeGrWindow(14, 7)
par(mfrow = c(1, 2))
cex1 <- 0.9
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[, 1], -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
  xlab = "Soft Threshold (power)", ylab = "Scale Free Topology Model Fit,signed R^2", type = "n",
  main = paste("Scale independence")
)
text(sft$fitIndices[, 1], -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
  labels = powers, cex = cex1, col = "red"
)
# this line corresponds to using an R^2 cut-off of h
abline(h = 0.90, col = "red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[, 1], sft$fitIndices[, 5],
  xlab = "Soft Threshold (power)", ylab = "Mean Connectivity", type = "n",
  main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1], sft$fitIndices[, 5], labels = powers, cex = cex1, col = "red")
```

```r
Connectivity <- softConnectivity(datExpr, power = sft$powerEstimate)
# pdf("scalefree.pdf",15,10)
par(mfrow = c(1, 1))
scaleFreePlot(Connectivity, main = paste("soft threshold, power=", sft$powerEstimate), truncated = T)
# dev.off()
```

## 网络构建和模块识别

### 自动一步网络构建和模块识别

```r
if (!file.exists("../examples/WGCNA/femaleMouseTOM-net.rda")) {
  net <- blockwiseModules(datExpr,
    power = sft$powerEstimate,
    TOMType = "unsigned", minModuleSize = 30,
    reassignThreshold = 0, mergeCutHeight = 0.25,
    numericLabels = TRUE, pamRespectsDendro = FALSE,
    saveTOMs = TRUE,
    saveTOMFileBase = "../examples/WGCNA/femaleMouseTOM",
    verbose = 3
  )
  save(net, file = "../examples/WGCNA/femaleMouseTOM-net.rda")
} else {
  load("../examples/WGCNA/femaleMouseTOM-net.rda")
}

if (!file.exists("../examples/WGCNA/FemaleLiver-02-networkConstruction-auto.RData")) {
  moduleLabels <- net$colors
  moduleColors <- labels2colors(net$colors)
  MEs <- net$MEs
  geneTree <- net$dendrograms[[1]]
  save(MEs, moduleLabels, moduleColors, geneTree,
    file = "../examples/WGCNA/FemaleLiver-02-networkConstruction-auto.RData"
  )
}
```

```r
# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting
mergedColors <- labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)
```

### 分步构建网络和识别模块

```r
# softPower = 6
softPower <- sft$powerEstimate
adjacency <- adjacency(datExpr, power = softPower)

# Turn adjacency into topological overlap
TOM <- TOMsimilarity(adjacency)
dissTOM <- 1 - TOM

# Call the hierarchical clustering function
geneTree <- hclust(as.dist(dissTOM), method = "average")
# Plot the resulting clustering tree (dendrogram)
sizeGrWindow(12, 9)
plot(geneTree,
  xlab = "", sub = "", main = "Gene clustering on TOM-based dissimilarity",
  labels = FALSE, hang = 0.04
)
```

```r
# We like large modules, so we set the minimum module size relatively high:
minModuleSize <- 30
# Module identification using dynamic tree cut:
dynamicMods <- cutreeDynamic(
  dendro = geneTree, distM = dissTOM,
  deepSplit = 2, pamRespectsDendro = FALSE,
  minClusterSize = minModuleSize
)
table(dynamicMods)
```

```r
# Convert numeric lables into colors
dynamicColors <- labels2colors(dynamicMods)
table(dynamicColors)
# Plot the dendrogram and colors underneath
sizeGrWindow(8, 6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05,
  main = "Gene dendrogram and module colors"
)
```

```r
# Calculate eigengenes
MEList <- moduleEigengenes(datExpr, colors = dynamicColors)
MEs <- MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss <- 1 - cor(MEs)
# Cluster module eigengenes
METree <- hclust(as.dist(MEDiss), method = "average")
# Plot the result
sizeGrWindow(7, 6)
plot(METree,
  main = "Clustering of module eigengenes",
  xlab = "", sub = ""
)

MEDissThres <- 0.25
# Plot the cut line into the dendrogram
abline(h = MEDissThres, col = "red")
```

```r
# Call an automatic merging function
merge <- mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
```

```r
# The merged module colors
mergedColors <- merge$colors
# Eigengenes of the new merged modules:
mergedMEs <- merge$newMEs

sizeGrWindow(12, 9)
# pdf(file = "Plots/geneDendro-3.pdf", wi = 9, he = 6)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
  c("Dynamic Tree Cut", "Merged dynamic"),
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)
# dev.off()
```

```r
# Rename to moduleColors
moduleColors <- mergedColors
# Construct numerical labels corresponding to the colors
colorOrder <- c("grey", standardColors(50))
moduleLabels <- match(moduleColors, colorOrder) - 1
MEs <- mergedMEs
# Save module colors and labels for use in subsequent parts
save(MEs, moduleLabels, moduleColors, geneTree, file = "../examples/WGCNA/FemaleLiver-02-networkConstruction-stepByStep.RData")
```

### block-wise大数据网络构建和模块识别

```r
bwnet <- blockwiseModules(datExpr,
  maxBlockSize = 2000,
  power = sft$powerEstimate,
  TOMType = "unsigned", minModuleSize = 30,
  reassignThreshold = 0, mergeCutHeight = 0.25,
  numericLabels = TRUE,
  loadTOM = TRUE,
  saveTOMs = TRUE,
  saveTOMFileBase = "../examples/WGCNA/femaleMouseTOM-blockwise",
  verbose = 3
)
```

```r
# Load the results of single-block analysis
load(file = "../examples/WGCNA/FemaleLiver-02-networkConstruction-auto.RData")
# Relabel blockwise modules
bwLabels <- matchLabels(bwnet$colors, moduleLabels)
# Convert labels to colors for plotting
bwModuleColors <- labels2colors(bwLabels)

# open a graphics window
sizeGrWindow(6, 6)
# Plot the dendrogram and the module colors underneath for block 1
plotDendroAndColors(bwnet$dendrograms[[1]], bwModuleColors[bwnet$blockGenes[[1]]],
  "Module colors",
  main = "Gene dendrogram and module colors in block 1",
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)
```

```r
# Plot the dendrogram and the module colors underneath for block 2
plotDendroAndColors(bwnet$dendrograms[[2]], bwModuleColors[bwnet$blockGenes[[2]]],
  "Module colors",
  main = "Gene dendrogram and module colors in block 2",
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)
```

```r
sizeGrWindow(12, 9)
plotDendroAndColors(geneTree,
  cbind(moduleColors, bwModuleColors),
  c("Single block", "2 blocks"),
  main = "Single block gene dendrogram and module colors",
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)
```

```r
singleBlockMEs <- moduleEigengenes(datExpr, moduleColors)$eigengenes
blockwiseMEs <- moduleEigengenes(datExpr, bwModuleColors)$eigengenes

single2blockwise <- match(names(singleBlockMEs), names(blockwiseMEs))
signif(diag(cor(blockwiseMEs[, single2blockwise], singleBlockMEs)), 3)
```

## 识别网络模块与外部临床特征、识别重要基因

```r
load(file = "../examples/WGCNA/FemaleLiver-01-dataInput.RData")
load(file = "../examples/WGCNA/FemaleLiver-02-networkConstruction-auto.RData")
# Define numbers of genes and samples
nGenes <- ncol(datExpr)
nSamples <- nrow(datExpr)
# Recalculate MEs with color labels
MEs0 <- moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs <- orderMEs(MEs0)
moduleTraitCor <- cor(MEs, datTraits, use = "p")
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples)
sizeGrWindow(18, 18)
# Will display correlations and their p-values
textMatrix <- paste(signif(moduleTraitCor, 2), "\n(",
  signif(moduleTraitPvalue, 1), ")",
  sep = ""
)
dim(textMatrix) <- dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3))
# Display the correlation values within a heatmap plot
labeledHeatmap(
  Matrix = moduleTraitCor,
  xLabels = names(datTraits),
  yLabels = names(MEs),
  ySymbols = names(MEs),
  colorLabels = FALSE,
  # colors = blueWhiteRed(50),
  colors = blueWhiteRed(50),
  textMatrix = textMatrix,
  setStdMargins = FALSE,
  cex.text = 0.5,
  zlim = c(-1, 1),
  main = paste("Module-trait relationships")
)
```

```r
# Define variable weight containing the weight column of datTrait
weight <- as.data.frame(datTraits$weight_g)
names(weight) <- "weight"
# names (colors) of the modules
modNames <- substring(names(MEs), 3)

geneModuleMembership <- as.data.frame(cor(datExpr, MEs, use = "p"))
MMPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))
names(geneModuleMembership) <- paste("MM", modNames, sep = "")
names(MMPvalue) <- paste("p.MM", modNames, sep = "")
geneTraitSignificance <- as.data.frame(cor(datExpr, weight, use = "p"))
GSPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) <- paste("GS.", names(weight), sep = "")
names(GSPvalue) <- paste("p.GS.", names(weight), sep = "")
module <- "brown"
column <- match(module, modNames)
moduleGenes <- moduleColors == module
sizeGrWindow(7, 7)
par(mfrow = c(1, 1))
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
  abs(geneTraitSignificance[moduleGenes, 1]),
  xlab = paste("Module Membership in", module, "module"),
  ylab = "Gene significance for body weight",
  main = paste("Module membership vs. gene significance\n"),
  cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module
)
```

```r
names(datExpr)[1:10]
names(datExpr)[moduleColors == "brown"][1:10]
```

```r
annot <- read.csv(file = "../examples/GeneAnnotation.csv")
dim(annot)
names(annot)
probes <- names(datExpr)
probes2annot <- match(probes, annot$substanceBXH)
# The following is the number or probes without annotation:
sum(is.na(probes2annot))
# Should return 0.
```

```r
# Create the starting data frame
geneInfo0 <- data.frame(
  substanceBXH = probes,
  geneSymbol = annot$gene_symbol[probes2annot],
  LocusLinkID = annot$LocusLinkID[probes2annot],
  moduleColor = moduleColors,
  geneTraitSignificance,
  GSPvalue
)
# Order modules by their significance for weight
modOrder <- order(-abs(cor(MEs, weight, use = "p")))
# Add module membership information in the chosen order
for (mod in 1:ncol(geneModuleMembership))
{
  oldNames <- names(geneInfo0)
  geneInfo0 <- data.frame(
    geneInfo0, geneModuleMembership[, modOrder[mod]],
    MMPvalue[, modOrder[mod]]
  )
  names(geneInfo0) <- c(
    oldNames, paste("MM.", modNames[modOrder[mod]], sep = ""),
    paste("p.MM.", modNames[modOrder[mod]], sep = "")
  )
}
# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder <- order(geneInfo0$moduleColor, -abs(geneInfo0$GS.weight))
geneInfo <- geneInfo0[geneOrder, ]

write.csv(geneInfo, file = "../examples/WGCNA/geneInfo.csv")
```

## 模块基因的功能注释和富集分析

```r
load(file = "../examples/WGCNA/FemaleLiver-01-dataInput.RData")
load(file = "../examples/WGCNA/FemaleLiver-02-networkConstruction-auto.RData")
```

```r
# Read in the probe annotation
annot <- read.csv(file = "../examples/GeneAnnotation.csv")
# Match probes in the data set to the probe IDs in the annotation file
probes <- names(datExpr)
probes2annot <- match(probes, annot$substanceBXH)
# Get the corresponding Locuis Link IDs
allLLIDs <- annot$LocusLinkID[probes2annot]
# $ Choose interesting modules
intModules <- c("brown", "red", "salmon")
for (module in intModules)
{
  # Select module probes
  modGenes <- (moduleColors == module)
  # Get their entrez ID codes
  modLLIDs <- allLLIDs[modGenes]
  # Write them into a file
  fileName <- paste("../examples/WGCNA/LocusLinkIDs-", module, ".txt", sep = "")
  write.table(as.data.frame(modLLIDs),
    file = fileName,
    row.names = FALSE, col.names = FALSE
  )
}
# As background in the enrichment analysis, we will use all probes in the analysis.
fileName <- paste("../examples/WGCNA/LocusLinkIDs-all.txt", sep = "")
write.table(as.data.frame(allLLIDs),
  file = fileName,
  row.names = FALSE, col.names = FALSE
)


GOcollection <- buildGOcollection(organism = "mouse")
GOenr <- enrichmentAnalysis(
  classLabels = moduleColors,
  identifiers = allLLIDs,
  refCollection = GOcollection,
  useBackground = "given",
  threshold = 1e-4,
  thresholdType = "Bonferroni",
  getOverlapEntrez = TRUE,
  getOverlapSymbols = TRUE,
  ignoreLabels = "grey"
)
```

```r
tab <- GOenr$enrichmentTable
names(tab)
```

```r
write.table(tab, file = "../examples/WGCNA/GOEnrichmentTable.csv", sep = ",", quote = TRUE, row.names = FALSE)
save(GOenr, file = "../examples/WGCNA/femaleMouse-enrichmentTable.RData")
```

```r
keepCols <- c(1, 3, 4, 6, 7, 8, 13)
screenTab <- tab[, keepCols]
# Round the numeric columns to 2 decimal places:
numCols <- c(4, 5, 6)
screenTab[, numCols] <- signif(apply(screenTab[, numCols], 2, as.numeric), 2)

# Shorten the column names:
colnames(screenTab) <- c("module", "GOID", "term name", "p-val", "Bonf", "FDR", "size")
rownames(screenTab) <- NULL
# Set the width of R's output. The reader should play with this number to obtain satisfactory output.
options(width = 95)
# Finally, display the enrichment table:
head(screenTab)
```

## 网络可视化

```r
load(file = "../examples/WGCNA/FemaleLiver-01-dataInput.RData")
load(file = "../examples/WGCNA/FemaleLiver-02-networkConstruction-auto.RData")
```

```r
nGenes <- ncol(datExpr)
nSamples <- nrow(datExpr)

# Calculate topological overlap anew: this could be done more efficiently by saving the TOM
# calculated during module detection, but let us do it again here.
dissTOM <- 1 - TOMsimilarityFromExpr(datExpr, power = 6)
```

```r
# Transform dissTOM with a power to make moderately strong connections more visible in the heatmap
plotTOM <- dissTOM^7
# Set diagonal to NA for a nicer plot
diag(plotTOM) <- NA
# Call the plot function
sizeGrWindow(9, 9)
TOMplot(plotTOM, geneTree, moduleColors, main = "Network heatmap plot, all genes")
```

```r
nSelect <- 400
# For reproducibility, we set the random seed
set.seed(10)
select <- sample(nGenes, size = nSelect)
selectTOM <- dissTOM[select, select]
# There's no simple way of restricting a clustering tree to a subset of genes, so we must re-cluster.
selectTree <- hclust(as.dist(selectTOM), method = "average")
selectColors <- moduleColors[select]
# Open a graphical window
sizeGrWindow(9, 9)
# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing
# the color palette; setting the diagonal to NA also improves the clarity of the plot
plotDiss <- selectTOM^7
diag(plotDiss) <- NA
TOMplot(plotDiss, selectTree, selectColors, main = "Network heatmap plot, selected genes")
```

```r
# Recalculate module eigengenes
MEs <- moduleEigengenes(datExpr, moduleColors)$eigengenes
# Isolate weight from the clinical traits
weight <- as.data.frame(datTraits$weight_g)
names(weight) <- "weight"
# Add the weight to existing module eigengenes
MET <- orderMEs(cbind(MEs, weight))
# Plot the relationships among the eigengenes and the trait
sizeGrWindow(5, 7.5)
par(cex = 0.9)
plotEigengeneNetworks(MET, "",
  marDendro = c(0, 4, 1, 2), marHeatmap = c(3, 4, 1, 2), cex.lab = 0.8,
  xLabelsAngle = 90
)
```

```r
# Plot the dendrogram
sizeGrWindow(6, 6)
par(cex = 1.0)
plotEigengeneNetworks(MET, "Eigengene dendrogram",
  marDendro = c(0, 4, 2, 0),
  plotHeatmaps = FALSE
)
# Plot the heatmap matrix (note: this plot will overwrite the dendrogram plot)
par(cex = 1.0)
plotEigengeneNetworks(MET, "Eigengene adjacency heatmap",
  marHeatmap = c(3, 4, 2, 2),
  plotDendrograms = FALSE, xLabelsAngle = 90
)
```

## 输出网络信息，使用外部软件可视化

```r
load(file = "../examples/WGCNA/FemaleLiver-01-dataInput.RData")
load(file = "../examples/WGCNA/FemaleLiver-02-networkConstruction-auto.RData")
```

```r
# Recalculate topological overlap
TOM <- TOMsimilarityFromExpr(datExpr, power = 6)
# Read in the annotation file
annot <- read.csv(file = "../examples/GeneAnnotation.csv")
# Select module
module <- "brown"
# Select module probes
probes <- names(datExpr)
inModule <- (moduleColors == module)
modProbes <- probes[inModule]
# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule]
dimnames(modTOM) <- list(modProbes, modProbes)
# Export the network into an edge list file VisANT can read
vis <- exportNetworkToVisANT(modTOM,
  file = paste("../examples/WGCNA/VisANTInput-", module, ".txt", sep = ""),
  weighted = TRUE,
  threshold = 0,
  probeToGene = data.frame(annot$substanceBXH, annot$gene_symbol)
)
```

```r
nTop <- 30
IMConn <- softConnectivity(datExpr[, modProbes])
top <- (rank(-IMConn) <= nTop)
vis <- exportNetworkToVisANT(modTOM[top, top],
  file = paste("../examples/WGCNA/VisANTInput-", module, "-top30.txt", sep = ""),
  weighted = TRUE,
  threshold = 0,
  probeToGene = data.frame(annot$substanceBXH, annot$gene_symbol)
)
```

```r
# Recalculate topological overlap if needed
TOM <- TOMsimilarityFromExpr(datExpr, power = 6)
# Read in the annotation file
annot <- read.csv(file = "../examples/GeneAnnotation.csv")
# Select modules
modules <- c("brown", "red")
# Select module probes
probes <- names(datExpr)
inModule <- is.finite(match(moduleColors, modules))
modProbes <- probes[inModule]
modGenes <- annot$gene_symbol[match(modProbes, annot$substanceBXH)]
# Select the corresponding Topological Overlap
modTOM <- TOM[inModule, inModule]
dimnames(modTOM) <- list(modProbes, modProbes)
# Export the network into edge and node list files Cytoscape can read
cyt <- exportNetworkToCytoscape(modTOM,
  edgeFile = paste("../examples/WGCNA/CytoscapeInput-edges-", paste(modules, collapse = "-"), ".txt", sep = ""),
  nodeFile = paste("../examples/WGCNA/CytoscapeInput-nodes-", paste(modules, collapse = "-"), ".txt", sep = ""),
  weighted = TRUE,
  threshold = 0.02,
  nodeNames = modProbes,
  altNodeNames = modGenes,
  nodeAttr = moduleColors[inModule]
)
```

# 公鼠和母鼠肝表达数据的一致性分析

![overview-Consensus](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/overview-Consensus.png)

## 数据清理，准备

```r
data("femData", package = "StatPlotR")
data("maleData", package = "StatPlotR")
# We work with two sets:
nSets <- 2
# For easier labeling of plots, create a vector holding descriptive names of the two sets.
setLabels <- c("Female liver", "Male liver")
shortLabels <- c("Female", "Male")
# Form multi-set expression data: columns starting from 9 contain actual expression data.
multiExpr <- vector(mode = "list", length = nSets)

multiExpr[[1]] <- list(data = as.data.frame(t(femData[-c(1:8)])))
names(multiExpr[[1]]$data) <- femData$substanceBXH
rownames(multiExpr[[1]]$data) <- names(femData)[-c(1:8)]
multiExpr[[2]] <- list(data = as.data.frame(t(maleData[-c(1:8)])))
names(multiExpr[[2]]$data) <- maleData$substanceBXH
rownames(multiExpr[[2]]$data) <- names(maleData)[-c(1:8)]
# Check that the data has the correct format for many functions operating on multiple sets:
exprSize <- checkSets(multiExpr)

# Check that all genes and samples have sufficiently low numbers of missing values.
gsg <- goodSamplesGenesMS(multiExpr, verbose = 3)
gsg$allOK
```

```r
if (!gsg$allOK) {
  # Print information about the removed genes:
  if (sum(!gsg$goodGenes) > 0) {
    printFlush(paste("Removing genes:", paste(names(multiExpr[[1]]$data)[!gsg$goodGenes],
      collapse = ", "
    )))
  }
  for (set in 1:exprSize$nSets)
  {
    if (sum(!gsg$goodSamples[[set]])) {
      printFlush(paste(
        "In set", setLabels[set], "removing samples",
        paste(rownames(multiExpr[[set]]$data)[!gsg$goodSamples[[set]]], collapse = ", ")
      ))
    }
    # Remove the offending genes and samples
    multiExpr[[set]]$data <- multiExpr[[set]]$data[gsg$goodSamples[[set]], gsg$goodGenes]
  }
  # Update exprSize
  exprSize <- checkSets(multiExpr)
}
```

```r
sampleTrees <- list()
for (set in 1:nSets)
{
  sampleTrees[[set]] <- hclust(dist(multiExpr[[set]]$data), method = "average")
}
```

```r
# pdf(file = "Plots/SampleClustering.pdf", width = 12, height = 12);
par(mfrow = c(2, 1))
par(mar = c(0, 4, 2, 0))
for (set in 1:nSets) {
  plot(sampleTrees[[set]],
    main = paste("Sample clustering on all genes in", setLabels[set]),
    xlab = "", sub = "", cex = 0.7
  )
}
# dev.off();
```

```r
# Choose the "base" cut height for the female data set
baseHeight <- 16
# Adjust the cut height for the male data set for the number of samples
cutHeights <- c(16, 16 * exprSize$nSamples[2] / exprSize$nSamples[1])
# Re-plot the dendrograms including the cut lines
# pdf(file = "Plots/SampleClustering.pdf", width = 12, height = 12);
par(mfrow = c(2, 1))
par(mar = c(0, 4, 2, 0))
for (set in 1:nSets)
{
  plot(sampleTrees[[set]],
    main = paste("Sample clustering on all genes in", setLabels[set]),
    xlab = "", sub = "", cex = 0.7
  )
  abline(h = cutHeights[set], col = "red")
}
# dev.off();
```

```r
for (set in 1:nSets)
{
  # Find clusters cut by the line
  labels <- cutreeStatic(sampleTrees[[set]], cutHeight = cutHeights[set])
  # Keep the largest one (labeled by the number 1)
  keep <- (labels == 1)
  multiExpr[[set]]$data <- multiExpr[[set]]$data[keep, ]
}
collectGarbage()
# Check the size of the leftover data
exprSize <- checkSets(multiExpr)
exprSize
```

```r
data("allTraits", package = "StatPlotR")

# Form a multi-set structure that will hold the clinical traits.
Traits <- vector(mode = "list", length = nSets)
for (set in 1:nSets)
{
  setSamples <- rownames(multiExpr[[set]]$data)
  traitRows <- match(setSamples, allTraits$Mice)
  Traits[[set]] <- list(data = allTraits[traitRows, -1])
  rownames(Traits[[set]]$data) <- allTraits$Mice[traitRows]
}
collectGarbage()
# Define data set dimensions
nGenes <- exprSize$nGenes
nSamples <- exprSize$nSamples
save(multiExpr, Traits, nGenes, nSamples, setLabels, shortLabels, exprSize,
  file = "../examples/WGCNA/Consensus-dataInput.RData"
)
```

## 选取软阈值

```r
load(file = "../examples/WGCNA/Consensus-dataInput.RData")
# The variable lnames contains the names of loaded variables.
lnames
# Get the number of sets in the multiExpr structure.
nSets <- checkSets(multiExpr)$nSets
```

```r
# Choose a set of soft-thresholding powers
powers <- c(seq(4, 10, by = 1), seq(12, 20, by = 2))
# Initialize a list to hold the results of scale-free analysis
powerTables <- vector(mode = "list", length = nSets)
# Call the network topology analysis function for each set in turn
for (set in 1:nSets) {
  powerTables[[set]] <- list(data = pickSoftThreshold(multiExpr[[set]]$data,
    powerVector = powers,
    verbose = 2
  )[[2]])
}
collectGarbage()
# Plot the results:
colors <- c("black", "red")
# Will plot these columns of the returned scale free analysis tables
plotCols <- c(2, 5, 6, 7)
colNames <- c(
  "Scale Free Topology Model Fit", "Mean connectivity", "Median connectivity",
  "Max connectivity"
)
# Get the minima and maxima of the plotted points
ylim <- matrix(NA, nrow = 2, ncol = 4)
for (set in 1:nSets)
{
  for (col in 1:length(plotCols))
  {
    ylim[1, col] <- min(ylim[1, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE)
    ylim[2, col] <- max(ylim[2, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE)
  }
}
# Plot the quantities in the chosen columns vs. the soft thresholding power
sizeGrWindow(8, 6)
# pdf(file = "Plots/scaleFreeAnalysis.pdf", wi = 8, he = 6)
par(mfcol = c(2, 2))
par(mar = c(4.2, 4.2, 2.2, 0.5))
cex1 <- 0.7
for (col in 1:length(plotCols)) {
  for (set in 1:nSets)
  {
    if (set == 1) {
      plot(powerTables[[set]]$data[, 1], -sign(powerTables[[set]]$data[, 3]) * powerTables[[set]]$data[, 2],
        xlab = "Soft Threshold (power)", ylab = colNames[col], type = "n", ylim = ylim[, col],
        main = colNames[col]
      )
      addGrid()
    }
    if (col == 1) {
      text(powerTables[[set]]$data[, 1], -sign(powerTables[[set]]$data[, 3]) * powerTables[[set]]$data[, 2],
        labels = powers, cex = cex1, col = colors[set]
      )
    } else {
      text(powerTables[[set]]$data[, 1], powerTables[[set]]$data[, plotCols[col]],
        labels = powers, cex = cex1, col = colors[set]
      )
    }
    if (col == 1) {
      legend("bottomright", legend = setLabels, col = colors, pch = 20)
    } else {
      legend("topright", legend = setLabels, col = colors, pch = 20)
    }
  }
}
# dev.off()
```

## 网络构建和模块识别

### 一步自动网络构建和模块识别

```r
net <- blockwiseConsensusModules(
  multiExpr,
  power = 6, minModuleSize = 30, deepSplit = 2,
  pamRespectsDendro = FALSE,
  mergeCutHeight = 0.25, numericLabels = TRUE,
  minKMEtoStay = 0,
  saveTOMs = TRUE, verbose = 5
)
```

```r
consMEs <- net$multiMEs
moduleLabels <- net$colors
# Convert the numeric labels to color labels
moduleColors <- labels2colors(moduleLabels)
consTree <- net$dendrograms[[1]]
sizeGrWindow(8, 6)
# pdf(file = "Plots/ConsensusDendrogram-auto.pdf", wi = 8, he = 6)
plotDendroAndColors(consTree, moduleColors,
  "Module colors",
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05,
  main = "Consensus gene dendrogram and module colors"
)

# dev.off()
```

```r
save(consMEs, moduleLabels, moduleColors, consTree, file = "../examples/WGCNA/Consensus-NetworkConstruction-auto.RData")
```

### 分布构建网络和模块识别：拓扑重叠矩阵

```r
softPower <- 6
# Initialize an appropriate array to hold the adjacencies
adjacencies <- array(0, dim = c(nSets, nGenes, nGenes))
# Calculate adjacencies in each individual data set
for (set in 1:nSets) {
  adjacencies[set, , ] <- abs(cor(multiExpr[[set]]$data, use = "p"))^softPower
}
```

```r
# Initialize an appropriate array to hold the TOMs
TOM <- array(0, dim = c(nSets, nGenes, nGenes))
# Calculate TOMs in each individual data set
for (set in 1:nSets) {
  TOM[set, , ] <- TOMsimilarity(adjacencies[set, , ])
}
```

```r
# Define the reference percentile
scaleP <- 0.95
# Set RNG seed for reproducibility of sampling
set.seed(12345)
# Sample sufficiently large number of TOM entries
nSamples <- as.integer(1 / (1 - scaleP) * 1000)
# Choose the sampled TOM entries
scaleSample <- sample(nGenes * (nGenes - 1) / 2, size = nSamples)
TOMScalingSamples <- list()
# These are TOM values at reference percentile
scaleQuant <- rep(1, nSets)
# Scaling powers to equalize reference TOM values
scalePowers <- rep(1, nSets)
# Loop over sets
for (set in 1:nSets)
{
  # Select the sampled TOM entries
  TOMScalingSamples[[set]] <- as.dist(TOM[set, , ])[scaleSample]
  # Calculate the 95th percentile
  scaleQuant[set] <- quantile(TOMScalingSamples[[set]],
    probs = scaleP, type = 8
  )
  # Scale the male TOM
  if (set > 1) {
    scalePowers[set] <- log(scaleQuant[1]) / log(scaleQuant[set])
    TOM[set, , ] <- TOM[set, , ]^scalePowers[set]
  }
}
```

```r
# For plotting, also scale the sampled TOM entries
scaledTOMSamples <- list()
for (set in 1:nSets) {
  scaledTOMSamples[[set]] <- TOMScalingSamples[[set]]^scalePowers[set]
}
# Open a suitably sized graphics window
sizeGrWindow(6, 6)
# pdf(file = "Plots/TOMScaling-QQPlot.pdf", wi = 6, he = 6);
# qq plot of the unscaled samples
qqUnscaled <- qqplot(TOMScalingSamples[[1]], TOMScalingSamples[[2]],
  plot.it = TRUE, cex = 0.6,
  xlab = paste("TOM in", setLabels[1]), ylab = paste("TOM in", setLabels[2]),
  main = "Q-Q plot of TOM", pch = 20
)
# qq plot of the scaled samples
qqScaled <- qqplot(scaledTOMSamples[[1]], scaledTOMSamples[[2]], plot.it = FALSE)
points(qqScaled$x, qqScaled$y, col = "red", cex = 0.6, pch = 20)
abline(a = 0, b = 1, col = "blue")
legend("topleft", legend = c("Unscaled TOM", "Scaled TOM"), pch = 20, col = c("black", "red"))
# dev.off();
```

```r
consensusTOM <- pmin(TOM[1, , ], TOM[2, , ])
```

```r
# Clustering
consTree <- hclust(as.dist(1 - consensusTOM), method = "average")
# We like large modules, so we set the minimum module size relatively high:
minModuleSize <- 30
# Module identification using dynamic tree cut:
unmergedLabels <- cutreeDynamic(
  dendro = consTree, distM = 1 - consensusTOM,
  deepSplit = 2, cutHeight = 0.995,
  minClusterSize = minModuleSize,
  pamRespectsDendro = FALSE
)
unmergedColors <- labels2colors(unmergedLabels)
```

```r
sizeGrWindow(8, 6)
plotDendroAndColors(consTree, unmergedColors, "Dynamic Tree Cut",
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)
```

```r
# Calculate module eigengenes
unmergedMEs <- multiSetMEs(multiExpr, colors = NULL, universalColors = unmergedColors)
# Calculate consensus dissimilarity of consensus module eigengenes
consMEDiss <- consensusMEDissimilarity(unmergedMEs)
# Cluster consensus modules
consMETree <- hclust(as.dist(consMEDiss), method = "average")
# Plot the result
sizeGrWindow(7, 6)
par(mfrow = c(1, 1))
plot(consMETree,
  main = "Consensus clustering of consensus module eigengenes",
  xlab = "", sub = ""
)
abline(h = 0.25, col = "red")
```

```r
merge <- mergeCloseModules(multiExpr, unmergedLabels, cutHeight = 0.25, verbose = 3)
```

```r
# Numeric module labels
moduleLabels <- merge$colors
# Convert labels to colors
moduleColors <- labels2colors(moduleLabels)
# Eigengenes of the new merged modules:
consMEs <- merge$newMEs
```

```r
sizeGrWindow(9, 6)
plotDendroAndColors(consTree, cbind(unmergedColors, moduleColors),
  c("Unmerged", "Merged"),
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05
)
```

```r
save(consMEs, moduleColors, moduleLabels, consTree, file = "../examples/WGCNA/Consensus-NetworkConstruction-man.RData")
```

### block-wise大数据网络构建和一致性网络构建

```r
bnet <- blockwiseConsensusModules(
  multiExpr,
  maxBlockSize = 2000, power = 6, minModuleSize = 30,
  deepSplit = 2,
  pamRespectsDendro = FALSE,
  mergeCutHeight = 0.25, numericLabels = TRUE,
  minKMEtoStay = 0,
  saveTOMs = TRUE, verbose = 5
)
```

```r
load(file = "../examples/WGCNA/Consensus-NetworkConstruction-auto.RData")
bwLabels <- matchLabels(bnet$colors, moduleLabels, pThreshold = 1e-7)
bwColors <- labels2colors(bwLabels)
```

```r
# Here we show a more flexible way of plotting several trees and colors on one page
sizeGrWindow(12, 6)
# pdf(file = "Plots/BlockwiseGeneDendrosAndColors.pdf", wi = 12, he = 6);
# Use the layout function for more involved screen sectioning
layout(matrix(c(1:4), 2, 2), heights = c(0.8, 0.2), widths = c(1, 1))
# layout.show(4);
nBlocks <- length(bnet$dendrograms)
# Plot the dendrogram and the module colors underneath for each block
for (block in 1:nBlocks) {
  plotDendroAndColors(bnet$dendrograms[[block]], moduleColors[bnet$blockGenes[[block]]],
    "Module colors",
    main = paste("Gene dendrogram and module colors in block", block),
    dendroLabels = FALSE, hang = 0.03,
    addGuide = TRUE, guideHang = 0.05,
    setLayout = FALSE
  )
}
# dev.off();
```

```r
sizeGrWindow(12, 9)
# pdf(file="Plots/SingleDendro-BWColors.pdf", wi = 12, he = 9);
plotDendroAndColors(consTree,
  cbind(moduleColors, bwColors),
  c("Single block", "Blockwise"),
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05,
  main = "Single block consensus gene dendrogram and module colors"
)
# dev.off();
```

## 一致性模块与母鼠网络模块的相关性

```r
load(file = "../examples/WGCNA/Consensus-dataInput.RData")
load(file = "../examples/WGCNA/Consensus-NetworkConstruction-auto.RData")
load("../examples/WGCNA/FemaleLiver-02-networkConstruction-auto.RData")
```

```r
# Rename variables to avoid conflicts
femaleLabels <- moduleLabels
femaleColors <- moduleColors
femaleTree <- geneTree
femaleMEs <- orderMEs(MEs, greyName = "ME0")
```

```r
# Isolate the module labels in the order they appear in ordered module eigengenes
femModuleLabels <- substring(names(femaleMEs), 3)
consModuleLabels <- substring(names(consMEs[[1]]$data), 3)
# Convert the numeric module labels to color labels
femModules <- labels2colors(as.numeric(femModuleLabels))
consModules <- labels2colors(as.numeric(consModuleLabels))
# Numbers of female and consensus modules
nFemMods <- length(femModules)
nConsMods <- length(consModules)
# Initialize tables of p-values and of the corresponding counts
pTable <- matrix(0, nrow = nFemMods, ncol = nConsMods)
CountTbl <- matrix(0, nrow = nFemMods, ncol = nConsMods)
# Execute all pairwaise comparisons
for (fmod in 1:nFemMods) {
  for (cmod in 1:nConsMods)
  {
    femMembers <- (femaleColors == femModules[fmod])
    consMembers <- (moduleColors == consModules[cmod])
    pTable[fmod, cmod] <- -log10(fisher.test(femMembers, consMembers, alternative = "greater")$p.value)
    CountTbl[fmod, cmod] <- sum(femaleColors == femModules[fmod] & moduleColors ==
      consModules[cmod])
  }
}
```

```r
# Truncate p values smaller than 10^{-50} to 10^{-50}
pTable[is.infinite(pTable)] <- 1.3 * max(pTable[is.finite(pTable)])
pTable[pTable > 50] <- 50
# Marginal counts (really module sizes)
femModTotals <- apply(CountTbl, 1, sum)
consModTotals <- apply(CountTbl, 2, sum)
# Actual plotting
sizeGrWindow(10, 7)
# pdf(file = "Plots/ConsensusVsFemaleModules.pdf", wi = 10, he = 7);
par(mfrow = c(1, 1))
par(cex = 1.0)
par(mar = c(8, 10.4, 2.7, 1) + 0.3)
# Use function labeledHeatmap to produce the color-coded table with all the trimmings
labeledHeatmap(
  Matrix = pTable,
  xLabels = paste(" ", consModules),
  yLabels = paste(" ", femModules),
  colorLabels = TRUE,
  xSymbols = paste("Cons ", consModules, ": ", consModTotals, sep = ""),
  ySymbols = paste("Fem ", femModules, ": ", femModTotals, sep = ""),
  textMatrix = CountTbl,
  colors = blueWhiteRed(100)[50:100],
  main = "Correspondence of Female set-specific and Female-Male consensus modules",
  cex.text = 1.0, cex.lab = 1.0, setStdMargins = FALSE
)
# dev.off();
```

## 一致性模块与外部样本信息的关系

```r
load(file = "../examples/WGCNA/Consensus-dataInput.RData")
load(file = "../examples/WGCNA/Consensus-NetworkConstruction-auto.RData")
exprSize <- checkSets(multiExpr)
nSets <- exprSize$nSets
```

```r
# Set up variables to contain the module-trait correlations
moduleTraitCor <- list()
moduleTraitPvalue <- list()
# Calculate the correlations
for (set in 1:nSets)
{
  moduleTraitCor[[set]] <- cor(consMEs[[set]]$data, Traits[[set]]$data, use = "p")
  moduleTraitPvalue[[set]] <- corPvalueFisher(moduleTraitCor[[set]], exprSize$nSamples[set])
}
```

```r
# Convert numerical lables to colors for labeling of modules in the plot
MEColors <- labels2colors(as.numeric(substring(names(consMEs[[1]]$data), 3)))
MEColorNames <- paste("ME", MEColors, sep = "")
# Open a suitably sized window (the user should change the window size if necessary)
sizeGrWindow(10, 7)
# pdf(file = "Plots/ModuleTraitRelationships-female.pdf", wi = 10, he = 7);
# Plot the module-trait relationship table for set number 1
set <- 1
textMatrix <- paste(signif(moduleTraitCor[[set]], 2), "\n(",
  signif(moduleTraitPvalue[[set]], 1), ")",
  sep = ""
)
dim(textMatrix) <- dim(moduleTraitCor[[set]])
par(mar = c(6, 8.8, 3, 2.2))
labeledHeatmap(
  Matrix = moduleTraitCor[[set]],
  xLabels = names(Traits[[set]]$data),
  yLabels = MEColorNames,
  ySymbols = MEColorNames,
  colorLabels = FALSE,
  colors = blueWhiteRed(50),
  textMatrix = textMatrix,
  setStdMargins = FALSE,
  cex.text = 0.5,
  zlim = c(-1, 1),
  main = paste("Module--trait relationships in", setLabels[set])
)
dev.off()
# Plot the module-trait relationship table for set number 2
set <- 2
textMatrix <- paste(signif(moduleTraitCor[[set]], 2), "\n(",
  signif(moduleTraitPvalue[[set]], 1), ")",
  sep = ""
)
dim(textMatrix) <- dim(moduleTraitCor[[set]])
sizeGrWindow(10, 7)
# pdf(file = "Plots/ModuleTraitRelationships-male.pdf", wi = 10, he = 7);
par(mar = c(6, 8.8, 3, 2.2))
labeledHeatmap(
  Matrix = moduleTraitCor[[set]],
  xLabels = names(Traits[[set]]$data),
  yLabels = MEColorNames,
  ySymbols = MEColorNames,
  colorLabels = FALSE,
  colors = blueWhiteRed(50),
  textMatrix = textMatrix,
  setStdMargins = FALSE,
  cex.text = 0.5,
  zlim = c(-1, 1),
  main = paste("Module--trait relationships in", setLabels[set])
)
# dev.off();
```

```r
# Initialize matrices to hold the consensus correlation and p-value
consensusCor <- matrix(NA, nrow(moduleTraitCor[[1]]), ncol(moduleTraitCor[[1]]))
consensusPvalue <- matrix(NA, nrow(moduleTraitCor[[1]]), ncol(moduleTraitCor[[1]]))
# Find consensus negative correlations
negative <- moduleTraitCor[[1]] < 0 & moduleTraitCor[[2]] < 0
consensusCor[negative] <- pmax(moduleTraitCor[[1]][negative], moduleTraitCor[[2]][negative])
consensusPvalue[negative] <- pmax(moduleTraitPvalue[[1]][negative], moduleTraitPvalue[[2]][negative])
# Find consensus positive correlations
positive <- moduleTraitCor[[1]] > 0 & moduleTraitCor[[2]] > 0
consensusCor[positive] <- pmin(moduleTraitCor[[1]][positive], moduleTraitCor[[2]][positive])
consensusPvalue[positive] <- pmax(moduleTraitPvalue[[1]][positive], moduleTraitPvalue[[2]][positive])
```

```r
textMatrix <- paste(signif(consensusCor, 2), "\n(",
  signif(consensusPvalue, 1), ")",
  sep = ""
)
dim(textMatrix) <- dim(moduleTraitCor[[set]])
sizeGrWindow(10, 7)
# pdf(file = "Plots/ModuleTraitRelationships-consensus.pdf", wi = 10, he = 7);
par(mar = c(6, 8.8, 3, 2.2))
labeledHeatmap(
  Matrix = consensusCor,
  xLabels = names(Traits[[set]]$data),
  yLabels = MEColorNames,
  ySymbols = MEColorNames,
  colorLabels = FALSE,
  colors = blueWhiteRed(50),
  textMatrix = textMatrix,
  setStdMargins = FALSE,
  cex.text = 0.5,
  zlim = c(-1, 1),
  main = paste(
    "Consensus module--trait relationships across\n",
    paste(setLabels, collapse = " and ")
  )
)
```

```r
file <- "../examples/GeneAnnotation.csv"
annot <- read.csv(file)
# Match probes in the data set to the probe IDs in the annotation file
probes <- names(multiExpr[[1]]$data)
probes2annot <- match(probes, annot$substanceBXH)
```

```r
consMEs.unord <- multiSetMEs(multiExpr, universalColors = moduleLabels, excludeGrey = TRUE)
GS <- list()
kME <- list()
for (set in 1:nSets)
{
  GS[[set]] <- corAndPvalue(multiExpr[[set]]$data, Traits[[set]]$data)
  kME[[set]] <- corAndPvalue(multiExpr[[set]]$data, consMEs.unord[[set]]$data)
}
```

```r
GS.metaZ <- (GS[[1]]$Z + GS[[2]]$Z) / sqrt(2)
kME.metaZ <- (kME[[1]]$Z + kME[[2]]$Z) / sqrt(2)
GS.metaP <- 2 * pnorm(abs(GS.metaZ), lower.tail = FALSE)
kME.metaP <- 2 * pnorm(abs(kME.metaZ), lower.tail = FALSE)
```

```r
GSmat <- rbind(GS[[1]]$cor, GS[[2]]$cor, GS[[1]]$p, GS[[2]]$p, GS.metaZ, GS.metaP)
nTraits <- checkSets(Traits)$nGenes
traitNames <- colnames(Traits[[1]]$data)
dim(GSmat) <- c(nGenes, 6 * nTraits)
rownames(GSmat) <- probes
colnames(GSmat) <- spaste(
  c("GS.set1.", "GS.set2.", "p.GS.set1.", "p.GS.set2.", "Z.GS.meta.", "p.GS.meta"),
  rep(traitNames, rep(6, nTraits))
)
# Same code for kME:
kMEmat <- rbind(kME[[1]]$cor, kME[[2]]$cor, kME[[1]]$p, kME[[2]]$p, kME.metaZ, kME.metaP)
MEnames <- colnames(consMEs.unord[[1]]$data)
nMEs <- checkSets(consMEs.unord)$nGenes
dim(kMEmat) <- c(nGenes, 6 * nMEs)
rownames(kMEmat) <- probes
colnames(kMEmat) <- spaste(
  c("kME.set1.", "kME.set2.", "p.kME.set1.", "p.kME.set2.", "Z.kME.meta.", "p.kME.meta"),
  rep(MEnames, rep(6, nMEs))
)
```

```r
info <- data.frame(
  Probe = probes, GeneSymbol = annot$gene_symbol[probes2annot],
  EntrezID = annot$LocusLinkID[probes2annot],
  ModuleLabel = moduleLabels,
  ModuleColor = labels2colors(moduleLabels),
  GSmat,
  kMEmat
)
write.csv(info,
  file = "../examples/WGCNA/consensusAnalysis-CombinedNetworkResults.csv",
  row.names = FALSE, quote = FALSE
)
```

## 研究和比较两个数据集的模块和特征：可视化

```r
load(file = "../examples/WGCNA/Consensus-dataInput.RData")
load(file = "../examples/WGCNA/Consensus-NetworkConstruction-auto.RData")
exprSize <- checkSets(multiExpr)
nSets <- exprSize$nSets
```

```r
# Set up variables to contain the module-trait correlations
moduleTraitCor <- list()
moduleTraitPvalue <- list()
# Calculate the correlations
for (set in 1:nSets)
{
  moduleTraitCor[[set]] <- cor(consMEs[[set]]$data, Traits[[set]]$data, use = "p")
  moduleTraitPvalue[[set]] <- corPvalueFisher(moduleTraitCor[[set]], exprSize$nSamples[set])
}
```

```r
# Convert numerical lables to colors for labeling of modules in the plot
MEColors <- labels2colors(as.numeric(substring(names(consMEs[[1]]$data), 3)))
MEColorNames <- paste("ME", MEColors, sep = "")
# Open a suitably sized window (the user should change the window size if necessary)
sizeGrWindow(10, 7)
# pdf(file = "Plots/ModuleTraitRelationships-female.pdf", wi = 10, he = 7);
# Plot the module-trait relationship table for set number 1
set <- 1
textMatrix <- paste(signif(moduleTraitCor[[set]], 2), "\n(",
  signif(moduleTraitPvalue[[set]], 1), ")",
  sep = ""
)
dim(textMatrix) <- dim(moduleTraitCor[[set]])
par(mar = c(6, 8.8, 3, 2.2))
labeledHeatmap(
  Matrix = moduleTraitCor[[set]],
  xLabels = names(Traits[[set]]$data),
  yLabels = MEColorNames,
  ySymbols = MEColorNames,
  colorLabels = FALSE,
  colors = blueWhiteRed(50),
  textMatrix = textMatrix,
  setStdMargins = FALSE,
  cex.text = 0.5,
  zlim = c(-1, 1),
  main = paste("Module--trait relationships in", setLabels[set])
)
# dev.off();
# Plot the module-trait relationship table for set number 2
set <- 2
textMatrix <- paste(signif(moduleTraitCor[[set]], 2), "\n(",
  signif(moduleTraitPvalue[[set]], 1), ")",
  sep = ""
)
dim(textMatrix) <- dim(moduleTraitCor[[set]])
sizeGrWindow(10, 7)
# pdf(file = "Plots/ModuleTraitRelationships-male.pdf", wi = 10, he = 7);
par(mar = c(6, 8.8, 3, 2.2))
labeledHeatmap(
  Matrix = moduleTraitCor[[set]],
  xLabels = names(Traits[[set]]$data),
  yLabels = MEColorNames,
  ySymbols = MEColorNames,
  colorLabels = FALSE,
  colors = blueWhiteRed(50),
  textMatrix = textMatrix,
  setStdMargins = FALSE,
  cex.text = 0.5,
  zlim = c(-1, 1),
  main = paste("Module--trait relationships in", setLabels[set])
)
# dev.off();
```

```r
# Initialize matrices to hold the consensus correlation and p-value
consensusCor <- matrix(NA, nrow(moduleTraitCor[[1]]), ncol(moduleTraitCor[[1]]))
consensusPvalue <- matrix(NA, nrow(moduleTraitCor[[1]]), ncol(moduleTraitCor[[1]]))
# Find consensus negative correlations
negative <- moduleTraitCor[[1]] < 0 & moduleTraitCor[[2]] < 0
consensusCor[negative] <- pmax(moduleTraitCor[[1]][negative], moduleTraitCor[[2]][negative])
consensusPvalue[negative] <- pmax(moduleTraitPvalue[[1]][negative], moduleTraitPvalue[[2]][negative])
# Find consensus positive correlations
positive <- moduleTraitCor[[1]] > 0 & moduleTraitCor[[2]] > 0
consensusCor[positive] <- pmin(moduleTraitCor[[1]][positive], moduleTraitCor[[2]][positive])
consensusPvalue[positive] <- pmax(moduleTraitPvalue[[1]][positive], moduleTraitPvalue[[2]][positive])
```

```r
textMatrix <- paste(signif(consensusCor, 2), "\n(",
  signif(consensusPvalue, 1), ")",
  sep = ""
)
dim(textMatrix) <- dim(moduleTraitCor[[set]])
sizeGrWindow(10, 7)
# pdf(file = "Plots/ModuleTraitRelationships-consensus.pdf", wi = 10, he = 7);
par(mar = c(6, 8.8, 3, 2.2))
labeledHeatmap(
  Matrix = consensusCor,
  xLabels = names(Traits[[set]]$data),
  yLabels = MEColorNames,
  ySymbols = MEColorNames,
  colorLabels = FALSE,
  colors = blueWhiteRed(50),
  textMatrix = textMatrix,
  setStdMargins = FALSE,
  cex.text = 0.5,
  zlim = c(-1, 1),
  main = paste(
    "Consensus module--trait relationships across\n",
    paste(setLabels, collapse = " and ")
  )
)
```

```r
file <- "../examples/GeneAnnotation.csv"
annot <- read.csv(file)
# Match probes in the data set to the probe IDs in the annotation file
probes <- names(multiExpr[[1]]$data)
probes2annot <- match(probes, annot$substanceBXH)
```

```r
consMEs.unord <- multiSetMEs(multiExpr, universalColors = moduleLabels, excludeGrey = TRUE)
GS <- list()
kME <- list()
for (set in 1:nSets)
{
  GS[[set]] <- corAndPvalue(multiExpr[[set]]$data, Traits[[set]]$data)
  kME[[set]] <- corAndPvalue(multiExpr[[set]]$data, consMEs.unord[[set]]$data)
}
```

```r
GS.metaZ <- (GS[[1]]$Z + GS[[2]]$Z) / sqrt(2)
kME.metaZ <- (kME[[1]]$Z + kME[[2]]$Z) / sqrt(2)
GS.metaP <- 2 * pnorm(abs(GS.metaZ), lower.tail = FALSE)
kME.metaP <- 2 * pnorm(abs(kME.metaZ), lower.tail = FALSE)
```

```r
GSmat <- rbind(GS[[1]]$cor, GS[[2]]$cor, GS[[1]]$p, GS[[2]]$p, GS.metaZ, GS.metaP)
nTraits <- checkSets(Traits)$nGenes
traitNames <- colnames(Traits[[1]]$data)
dim(GSmat) <- c(nGenes, 6 * nTraits)
rownames(GSmat) <- probes
colnames(GSmat) <- spaste(
  c("GS.set1.", "GS.set2.", "p.GS.set1.", "p.GS.set2.", "Z.GS.meta.", "p.GS.meta"),
  rep(traitNames, rep(6, nTraits))
)
# Same code for kME:
kMEmat <- rbind(kME[[1]]$cor, kME[[2]]$cor, kME[[1]]$p, kME[[2]]$p, kME.metaZ, kME.metaP)
MEnames <- colnames(consMEs.unord[[1]]$data)
nMEs <- checkSets(consMEs.unord)$nGenes
dim(kMEmat) <- c(nGenes, 6 * nMEs)
rownames(kMEmat) <- probes
colnames(kMEmat) <- spaste(
  c("kME.set1.", "kME.set2.", "p.kME.set1.", "p.kME.set2.", "Z.kME.meta.", "p.kME.meta"),
  rep(MEnames, rep(6, nMEs))
)
```

```r
info <- data.frame(
  Probe = probes, GeneSymbol = annot$gene_symbol[probes2annot],
  EntrezID = annot$LocusLinkID[probes2annot],
  ModuleLabel = moduleLabels,
  ModuleColor = labels2colors(moduleLabels),
  GSmat,
  kMEmat
)
write.csv(info,
  file = "../examples/WGCNA/consensusAnalysis-CombinedNetworkResults.csv",
  row.names = FALSE, quote = FALSE
)
```

# 模拟数据分析

## 表达数据和特征数据

```r
rm(list = ls())
# Here are input parameters of the simulation model
# number of samples or microarrays in the training data
no.obs <- 50
# now we specify the true measures of eigengene significance
# recall that ESturquoise=cor(y,MEturquoise)
ESturquoise <- 0
ESbrown <- -.6
ESgreen <- .6
ESyellow <- 0
# Note that we don鈥檛 specify the eigengene significance of the blue module
# since it is highly correlated with the turquoise module.
ESvector <- c(ESturquoise, ESbrown, ESgreen, ESyellow)
# number of genes
nGenes1 <- 3000
# proportion of genes in the turquoise, blue, brown, green, and yellow module #respectively.
simulateProportions1 <- c(0.2, 0.15, 0.08, 0.06, 0.04)
# Note that the proportions don鈥檛 add up to 1. The remaining genes will be colored grey,
# ie the grey genes are non-module genes.
# set the seed of the random number generator. As a homework exercise change this seed.
set.seed(1)
# Step 1: simulate a module eigengene network.
# Training Data Set I
MEgreen <- rnorm(no.obs)
scaledy <- MEgreen * ESgreen + sqrt(1 - ESgreen^2) * rnorm(no.obs)
y <- ifelse(scaledy > median(scaledy), 2, 1)
MEturquoise <- ESturquoise * scaledy + sqrt(1 - ESturquoise^2) * rnorm(no.obs)
# we simulate a strong dependence between MEblue and MEturquoise
MEblue <- .6 * MEturquoise + sqrt(1 - .6^2) * rnorm(no.obs)
MEbrown <- ESbrown * scaledy + sqrt(1 - ESbrown^2) * rnorm(no.obs)
MEyellow <- ESyellow * scaledy + sqrt(1 - ESyellow^2) * rnorm(no.obs)
ModuleEigengeneNetwork1 <- data.frame(y, MEturquoise, MEblue, MEbrown, MEgreen, MEyellow)
```

```r
dat1 <- simulateDatExpr5Modules(
  MEturquoise = ModuleEigengeneNetwork1$MEturquoise,
  MEblue = ModuleEigengeneNetwork1$MEblue,
  MEbrown = ModuleEigengeneNetwork1$MEbrown,
  MEyellow = ModuleEigengeneNetwork1$MEyellow,
  MEgreen = ModuleEigengeneNetwork1$MEgreen,
  nGenes = nGenes1,
  simulateProportions = simulateProportions1
)
```

```r
datExpr <- dat1$datExpr
truemodule <- dat1$truemodule
datME <- dat1$datME
attach(ModuleEigengeneNetwork1)
```

```r
table(truemodule)
dim(datExpr)
```

```r
datExpr <- data.frame(datExpr)
ArrayName <- paste("Sample", 1:dim(datExpr)[[1]], sep = "")
# The following code is useful for outputting the simulated data
GeneName <- paste("Gene", 1:dim(datExpr)[[2]], sep = "")
dimnames(datExpr)[[1]] <- ArrayName
dimnames(datExpr)[[2]] <- GeneName
```

```r
rm(dat1)
collectGarbage()
# The following command will save all variables defined in the current session.
save.image("Simulated-dataSimulation.RData")
```

## 另一个数据集

```r
rm(list = ls())
datGeneSummary <- read.csv("../examples/GeneSummaryTutorial.csv")
datTraits <- read.csv("../examples/TraitsTutorial.csv")
datMicroarrays <- read.csv("../examples/MicroarrayDataTutorial.csv")
```

```r
# This vector contains the microarray sample names
ArrayName <- names(data.frame(datMicroarrays[, -1]))
# This vector contains the gene names
GeneName <- datMicroarrays$GeneName
# We transpose the data so that the rows correspond to samples and the columns correspond to genes
# Since the first column contains the gene names, we exclude it.
datExpr <- data.frame(t(datMicroarrays[, -1]))
names(datExpr) <- datMicroarrays[, 1]
dimnames(datExpr)[[1]] <- names(data.frame(datMicroarrays[, -1]))
# Also, since we simulated the data, we know the true module color:
truemodule <- datGeneSummary$truemodule
rm(datMicroarrays)
collectGarbage()
```

```r
# First, make sure that the array names in the file datTraits line up with those in the microarray data
table(dimnames(datExpr)[[1]] == datTraits$ArrayName)
# Next, define the microarray sample trait
y <- datTraits$y
```

## 处理缺失值和去除离群样本

```r
rm(list = ls())
# Load the previously saved data
load("../examples/WGCNA/Simulated-dataSimulation.RData")
attach(ModuleEigengeneNetwork1)
```

```r
meanExpressionByArray <- apply(datExpr, 1, mean, na.rm = T)
NumberMissingByArray <- apply(is.na(data.frame(datExpr)), 1, sum)
```

```r
sizeGrWindow(9, 5)
barplot(meanExpressionByArray,
  xlab = "Sample", ylab = "Mean expression",
  main = "Mean expression across samples",
  names.arg = c(1:50), cex.names = 0.7
)
```

```r
# Keep only arrays containing less than 500 missing entries
KeepArray <- NumberMissingByArray < 500
table(KeepArray)
datExpr <- datExpr[KeepArray, ]
y <- y[KeepArray]
ArrayName[KeepArray]
```

```r
NumberMissingByGene <- apply(is.na(data.frame(datExpr)), 2, sum)
# One could do a barplot(NumberMissingByGene), but the barplot is empty in this case.
# It may be better to look at the numbers of missing samples using the summary method:
summary(NumberMissingByGene)
# Calculate the variances of the probes and the number of present entries
variancedatExpr <- as.vector(apply(as.matrix(datExpr), 2, var, na.rm = T))
no.presentdatExpr <- as.vector(apply(!is.na(as.matrix(datExpr)), 2, sum))
# Another way of summarizing the number of pressent entries
table(no.presentdatExpr)
# Keep only genes whose variance is non-zero and have at least 4 present entries
KeepGenes <- variancedatExpr > 0 & no.presentdatExpr >= 4
table(KeepGenes)
datExpr <- datExpr[, KeepGenes]
GeneName <- GeneName[KeepGenes]
```

```r
sizeGrWindow(9, 5)
plotClusterTreeSamples(datExpr = datExpr, y = y)
```

## Pearson相关性筛选基因

```r
rm(list = ls())

# Load the previously saved data
load("../examples/WGCNA/Simulated-dataSimulation.RData")
attach(ModuleEigengeneNetwork1)
```

```r
GS1 <- as.numeric(cor(y, datExpr, use = "p"))
# Network terminology: GS1 will be referred to as signed gene significance measure
p.Standard <- corPvalueFisher(GS1, nSamples = length(y))
# since the q-value function has problems with missing data, we use the following trick
p.Standard2 <- p.Standard
p.Standard2[is.na(p.Standard)] <- 1
q.Standard <- qvalue(p.Standard2)$qvalues
# Form a data frame to hold the results
StandardGeneScreeningResults <- data.frame(GeneName, PearsonCorrelation = GS1, p.Standard, q.Standard)
```

```r
NoiseGeneIndicator <- is.element(truemodule, c("turquoise", "blue", "yellow", "grey")) + .0
SignalGeneIndicator <- 1 - NoiseGeneIndicator
```

```r
table(q.Standard < .20)
```

```r
mean(NoiseGeneIndicator[q.Standard <= 0.20])
```

```r
save.image(file = "../examples/WGCNA/Simulated-StandardScreening.RData")
```

## 分步构建网络

```r
rm(list = ls())
# Load the previously saved data
load("../examples/WGCNA/Simulated-StandardScreening.RData")
attach(ModuleEigengeneNetwork1)
```

```r
# here we define the adjacency matrix using soft thresholding with beta=6
ADJ1 <- abs(cor(datExpr, use = "p"))^6
# When you have relatively few genes (<5000) use the following code
k <- as.vector(apply(ADJ1, 2, sum, na.rm = T))
# When you have a lot of genes use the following code
k <- softConnectivity(datE = datExpr, power = 6)
# Plot a histogram of k and a scale free topology plot
sizeGrWindow(10, 5)
par(mfrow = c(1, 2))
hist(k)
scaleFreePlot(k, main = "Check scale free topology\n")
```

```r
datExpr <- datExpr[, rank(-k, ties.method = "first") <= 3600]
```

```r
# Turn adjacency into a measure of dissimilarity
dissADJ <- 1 - ADJ1
```

```r
dissTOM <- TOMdist(ADJ1)
collectGarbage()
```

```r
pam4 <- pam(as.dist(dissADJ), 4)
pam5 <- pam(as.dist(dissADJ), 5)
pam6 <- pam(as.dist(dissADJ), 6)
# Cross-tabulte the detected and the true (simulated) module membership:
table(pam4$clustering, truemodule)
table(pam5$clustering, truemodule)
table(pam6$clustering, truemodule)
```

```r
pamTOM4 <- pam(as.dist(dissTOM), 4)
pamTOM5 <- pam(as.dist(dissTOM), 5)
pamTOM6 <- pam(as.dist(dissTOM), 6)
# Cross-tabulte the detected and the true (simulated) module membership:
table(pamTOM4$clustering, truemodule)
table(pamTOM5$clustering, truemodule)
table(pamTOM6$clustering, truemodule)
```

```r
hierADJ <- hclust(as.dist(dissADJ), method = "average")
# Plot the resulting clustering tree together with the true color assignment
sizeGrWindow(10, 5)
plotDendroAndColors(hierADJ,
  colors = data.frame(truemodule), dendroLabels = FALSE, hang = 0.03,
  main = "Gene hierarchical clustering dendrogram and simulated module colors"
)
```

```r
colorStaticADJ <- as.character(cutreeStaticColor(hierADJ, cutHeight = .99, minSize = 20))
# Plot the dendrogram with module colors
sizeGrWindow(10, 5)
plotDendroAndColors(hierADJ,
  colors = data.frame(truemodule, colorStaticADJ),
  dendroLabels = FALSE, abHeight = 0.99,
  main = "Gene dendrogram and module colors"
)
```

```r
branch.number <- cutreeDynamic(hierADJ, method = "tree")
# This function transforms the branch numbers into colors
colorDynamicADJ <- labels2colors(branch.number)
```

```r
colorDynamicHybridADJ <- labels2colors(cutreeDynamic(hierADJ,
  distM = dissADJ,
  cutHeight = 0.998, deepSplit = 2, pamRespectsDendro = FALSE
))

# Plot results of all module detection methods together:
sizeGrWindow(10, 5)
plotDendroAndColors(
  dendro = hierADJ,
  colors = data.frame(
    truemodule, colorStaticADJ,
    colorDynamicADJ, colorDynamicHybridADJ
  ),
  dendroLabels = FALSE, marAll = c(0.2, 8, 2.7, 0.2),
  main = "Gene dendrogram and module colors"
)
```

```r
# Calculate the dendrogram
hierTOM <- hclust(as.dist(dissTOM), method = "average")
# The reader should vary the height cut-off parameter h1
# (related to the y-axis of dendrogram) in the following
colorStaticTOM <- as.character(cutreeStaticColor(hierTOM, cutHeight = .99, minSize = 20))
colorDynamicTOM <- labels2colors(cutreeDynamic(hierTOM, method = "tree"))
colorDynamicHybridTOM <- labels2colors(cutreeDynamic(hierTOM,
  distM = dissTOM, cutHeight = 0.998,
  deepSplit = 2, pamRespectsDendro = FALSE
))
# Now we plot the results
sizeGrWindow(10, 5)
plotDendroAndColors(hierTOM,
  colors = data.frame(
    truemodule, colorStaticTOM,
    colorDynamicTOM, colorDynamicHybridTOM
  ),
  dendroLabels = FALSE, marAll = c(1, 8, 3, 1),
  main = "Gene dendrogram and module colors, TOM dissimilarity"
)
```

```r
tabStaticADJ <- table(colorStaticADJ, truemodule)
tabStaticTOM <- table(colorStaticTOM, truemodule)
tabDynamicADJ <- table(colorDynamicADJ, truemodule)
tabDynamicTOM <- table(colorDynamicTOM, truemodule)
tabDynamicHybridADJ <- table(colorDynamicHybridADJ, truemodule)
tabDynamicHybridTOM <- table(colorDynamicHybridTOM, truemodule)
```

```r
randIndex(tabStaticADJ, adjust = F)
randIndex(tabStaticTOM, adjust = F)
randIndex(tabDynamicADJ, adjust = F)
randIndex(tabDynamicTOM, adjust = F)
randIndex(tabDynamicHybridADJ, adjust = F)
randIndex(tabDynamicHybridTOM, adjust = F)
```

```r
colorh1 <- colorDynamicHybridTOM
# remove the dissimilarities, adjacency matrices etc to free up space
rm(ADJ1)
rm(dissADJ)
collectGarbage()
save.image("../examples/WGCNA/Simulated-NetworkConstruction.RData")
```

## 与外部信息关联分析

```r
rm(list = ls())
# Load the previously saved data
load("../examples/WGCNA/Simulated-NetworkConstruction.RData")
attach(ModuleEigengeneNetwork1)
```

```r
datME <- moduleEigengenes(datExpr, colorh1)$eigengenes
signif(cor(datME, use = "p"), 2)
```

```r
dissimME <- (1 - t(cor(datME, method = "p"))) / 2
hclustdatME <- hclust(as.dist(dissimME), method = "average")
# Plot the eigengene dendrogram
par(mfrow = c(1, 1))
plot(hclustdatME, main = "Clustering tree based of the module eigengenes")
```

```r
sizeGrWindow(8, 9)
plotMEpairs(datME, y = y)
```

```r
signif(cor(datME, ModuleEigengeneNetwork1[, -1]), 2)
```

```r
sizeGrWindow(8, 9)
par(mfrow = c(3, 1), mar = c(1, 2, 4, 1))
which.module <- "turquoise"
plotMat(t(scale(datExpr[, colorh1 == which.module])),
  nrgcols = 30, rlabels = T,
  clabels = T, rcols = which.module,
  title = which.module
)
# for the second (blue) module we use
which.module <- "blue"
plotMat(t(scale(datExpr[, colorh1 == which.module])),
  nrgcols = 30, rlabels = T,
  clabels = T, rcols = which.module,
  title = which.module
)
which.module <- "brown"
plotMat(t(scale(datExpr[, colorh1 == which.module])),
  nrgcols = 30, rlabels = T,
  clabels = T, rcols = which.module,
  title = which.module
)
```

```r
sizeGrWindow(8, 7)
which.module <- "green"
ME <- datME[, paste("ME", which.module, sep = "")]
par(mfrow = c(2, 1), mar = c(0.3, 5.5, 3, 2))
plotMat(t(scale(datExpr[, colorh1 == which.module])),
  nrgcols = 30, rlabels = F, rcols = which.module,
  main = which.module, cex.main = 2
)
par(mar = c(5, 4.2, 0, 0.7))
barplot(ME,
  col = which.module, main = "", cex.main = 2,
  ylab = "eigengene expression", xlab = "array sample"
)
```

```r
signif(cor(y, datME, use = "p"), 2)
```

```r
cor.test(y, datME$MEbrown)
```

```r
p.values <- corPvalueStudent(cor(y, datME, use = "p"), nSamples = length(y))
```

```r
GS1 <- as.numeric(cor(y, datExpr, use = "p"))
GeneSignificance <- abs(GS1)
# Next module significance is defined as average gene significance.
ModuleSignificance <- tapply(GeneSignificance, colorh1, mean, na.rm = T)
```

```r
sizeGrWindow(8, 7)
par(mfrow = c(1, 1))
plotModuleSignificance(GeneSignificance, colorh1)
```

```r
collectGarbage()
save.image("../examples/WGCNA/Simulated-RelatingToExt.RData")
```

## 模块成员资格，模块内连通性和模块内中心基因的筛选:使用模块内连通性来定义模块成员性的度量并基于网络信息筛选基因

```r
rm(list = ls())

# Load the previously saved data
load("../examples/WGCNA/Simulated-RelatingToExt.RData")
```

```r
ADJ1 <- abs(cor(datExpr, use = "p"))^6
Alldegrees1 <- intramodularConnectivity(ADJ1, colorh1)
head(Alldegrees1)
```

```r
colorlevels <- unique(colorh1)
sizeGrWindow(9, 6)
par(mfrow = c(2, as.integer(0.5 + length(colorlevels) / 2)))
par(mar = c(4, 5, 3, 1))
for (i in c(1:length(colorlevels)))
{
  whichmodule <- colorlevels[[i]]
  restrict1 <- (colorh1 == whichmodule)
  verboseScatterplot(Alldegrees1$kWithin[restrict1],
    GeneSignificance[restrict1],
    col = colorh1[restrict1],
    main = whichmodule,
    xlab = "Connectivity", ylab = "Gene Significance", abline = TRUE
  )
}
```

```r
datKME <- signedKME(datExpr, datME, outputColumnName = "MM.")
# Display the first few rows of the data frame
head(datKME)
```

```r
FilterGenes <- abs(GS1) > .2 & abs(datKME$MM.brown) > .8
table(FilterGenes)
```

```r
dimnames(data.frame(datExpr))[[2]][FilterGenes]
```

```r
sizeGrWindow(8, 6)
par(mfrow = c(2, 2))
# We choose 4 modules to plot: turquoise, blue, brown, green.
# For simplicity we write the code out explicitly for each module.
which.color <- "turquoise"
restrictGenes <- colorh1 == which.color
verboseScatterplot(Alldegrees1$kWithin[restrictGenes],
  (datKME[restrictGenes, paste("MM.", which.color, sep = "")])^6,
  col = which.color,
  xlab = "Intramodular Connectivity",
  ylab = "(Module Membership)^6"
)

which.color <- "blue"
restrictGenes <- colorh1 == which.color
verboseScatterplot(Alldegrees1$kWithin[restrictGenes],
  (datKME[restrictGenes, paste("MM.", which.color, sep = "")])^6,
  col = which.color,
  xlab = "Intramodular Connectivity",
  ylab = "(Module Membership)^6"
)

which.color <- "brown"
restrictGenes <- colorh1 == which.color
verboseScatterplot(Alldegrees1$kWithin[restrictGenes],
  (datKME[restrictGenes, paste("MM.", which.color, sep = "")])^6,
  col = which.color,
  xlab = "Intramodular Connectivity",
  ylab = "(Module Membership)^6"
)

which.color <- "green"
restrictGenes <- colorh1 == which.color
verboseScatterplot(Alldegrees1$kWithin[restrictGenes],
  (datKME[restrictGenes, paste("MM.", which.color, sep = "")])^6,
  col = which.color,
  xlab = "Intramodular Connectivity",
  ylab = "(Module Membership)^6"
)
```

```r
NS1 <- networkScreening(
  y = y, datME = datME, datExpr = datExpr,
  oddPower = 3, blockSize = 1000, minimumSampleSize = 4,
  addMEy = TRUE, removeDiag = FALSE, weightESy = 0.5
)
```

```r
# network screening analysis
mean(NoiseGeneIndicator[rank(NS1$p.Weighted, ties.method = "first") <= 100])
# standard analysis based on the correlation p-values (or Student T test)
mean(NoiseGeneIndicator[rank(NS1$p.Standard, ties.method = "first") <= 100])
```

```r
topNumbers <- c(10, 20, 50, 100)
for (i in c(1:length(topNumbers)))
{
  print(paste("Proportion of noise genes in the top", topNumbers[i], "list"))
  WGCNApropNoise <- mean(NoiseGeneIndicator[rank(NS1$p.Weighted, ties.method = "first") <= topNumbers[i]])
  StandardpropNoise <- mean(NoiseGeneIndicator[rank(NS1$p.Standard, ties.method = "first") <= topNumbers[i]])
  print(paste(
    "WGCNA, proportion of noise=", WGCNApropNoise,
    ", Standard, prop. noise=", StandardpropNoise
  ))
  if (WGCNApropNoise < StandardpropNoise) print("WGCNA wins")
  if (WGCNApropNoise == StandardpropNoise) print("both methods tie")
  if (WGCNApropNoise > StandardpropNoise) print("standard screening wins")
}
```

```r
rm(dissTOM)
collectGarbage()
```

```r
# Form a data frame containing standard and network screening results
CorPrediction1 <- data.frame(GS1, NS1$cor.Weighted)
cor.Weighted <- NS1$cor.Weighted
# Plot the comparison
sizeGrWindow(8, 6)
verboseScatterplot(cor.Weighted, GS1,
  main = "Network-based weighted correlation versus Pearson correlation\n",
  col = truemodule, cex.main = 1.2
)
abline(0, 1)
```

```r
set.seed(2)
nSamples2 <- 2000
MEgreen <- rnorm(nSamples2)
scaledy2 <- MEgreen * ESgreen + sqrt(1 - ESgreen^2) * rnorm(nSamples2)
y2 <- ifelse(scaledy2 > median(scaledy2), 2, 1)
MEturquoise <- ESturquoise * scaledy2 + sqrt(1 - ESturquoise^2) * rnorm(nSamples2)
# we simulate a strong dependence between MEblue and MEturquoise
MEblue <- .6 * MEturquoise + sqrt(1 - .6^2) * rnorm(nSamples2)
MEbrown <- ESbrown * scaledy2 + sqrt(1 - ESbrown^2) * rnorm(nSamples2)
MEyellow <- ESyellow * scaledy2 + sqrt(1 - ESyellow^2) * rnorm(nSamples2)
# Put together a data frame of eigengenes
ModuleEigengeneNetwork2 <- data.frame(y = y2, MEturquoise, MEblue, MEbrown, MEgreen, MEyellow)
# Simulate the expression data
dat2 <- simulateDatExpr5Modules(
  MEturquoise = ModuleEigengeneNetwork2$MEturquoise,
  MEblue = ModuleEigengeneNetwork2$MEblue, MEbrown = ModuleEigengeneNetwork2$MEbrown,
  MEyellow = ModuleEigengeneNetwork2$MEyellow,
  MEgreen = ModuleEigengeneNetwork2$MEgreen, simulateProportions = simulateProportions1,
  nGenes = nGenes1
)
# recall that this is the signed gene significance in the training data
GS1 <- as.numeric(cor(y, datExpr, use = "p"))
# the following is the signed gene significance in the test data
GS2 <- as.numeric(cor(ModuleEigengeneNetwork2$y, dat2$datExpr, use = "p"))
```

```r
sizeGrWindow(8, 6)
par(mfrow = c(1, 1))
verboseScatterplot(GS1, GS2,
  main = "Trait-based gene significance in test set vs. training set\n",
  xlab = "Training set gene significance",
  ylab = "Test set gene significance",
  col = truemodule, cex.main = 1.4
)
```

```r
EvaluationGeneScreening1 <- corPredictionSuccess(
  corPrediction = CorPrediction1,
  corTestSet = GS2,
  topNumber = seq(from = 20, to = 500, length = 30)
)
par(mfrow = c(2, 2))
listcomp <- EvaluationGeneScreening1$meancorTestSetOverall
matplot(
  x = listcomp$topNumber,
  y = listcomp[, -1],
  main = "Predicting positive and negative correlations",
  ylab = "mean cor, test data",
  xlab = "top number of genes in the training data"
)
listcomp <- EvaluationGeneScreening1$meancorTestSetPositive
matplot(
  x = listcomp$topNumber,
  y = listcomp[, -1],
  main = "Predicting positive correlations",
  ylab = "mean cor, test data",
  xlab = "top number of genes in the training data"
)
listcomp <- EvaluationGeneScreening1$meancorTestSetNegative
matplot(
  x = listcomp$topNumber,
  y = listcomp[, -1],
  main = "Predicting negative correlations",
  ylab = "mean cor, test data",
  xlab = "top number of genes in the training data"
)
```

```r
relativeCorPredictionSuccess(
  corPredictionNew = NS1$cor.Weighted,
  corPredictionStandard = GS1,
  corTestSet = GS2,
  topNumber = c(10, 20, 50, 100, 200, 500)
)
```

```r
# Create a data frame holding the results of gene screening
GeneResultsNetworkScreening <- data.frame(GeneName = row.names(NS1), NS1)
# Write the data frame into a file
write.table(GeneResultsNetworkScreening,
  file = "../examples/WGCNA/GeneResultsNetworkScreening.csv",
  row.names = F, sep = ","
)
# Output of eigengene information:
datMEy <- data.frame(y, datME)
eigengeneSignificance <- cor(datMEy, y)
eigengeneSignificance[1, 1] <- (1 + max(eigengeneSignificance[-1, 1])) / 2
eigengeneSignificance.pvalue <- corPvalueStudent(eigengeneSignificance, nSamples = length(y))
namesME <- names(datMEy)
# Form a summary data frame
out1 <- data.frame(t(data.frame(
  eigengeneSignificance,
  eigengeneSignificance.pvalue, namesME, t(datMEy)
)))
# Set appropriate row names
dimnames(out1)[[1]][1] <- "EigengeneSignificance"
dimnames(out1)[[1]][2] <- "EigengeneSignificancePvalue"
dimnames(out1)[[1]][3] <- "ModuleEigengeneName"
dimnames(out1)[[1]][-c(1:3)] <- dimnames(datExpr)[[1]]
# Write the data frame into a file
write.table(out1, file = "../examples/WGCNA/MEResultsNetworkScreening.csv", row.names = TRUE, col.names = TRUE, sep = ",")
# Display the first few rows:
head(out1)
```

```r
# Write out gene information
GeneName <- dimnames(datExpr)[[2]]
GeneSummary <- data.frame(GeneName, truemodule, SignalGeneIndicator, NS1)
write.table(GeneSummary, file = "../examples/WGCNA/GeneSummaryTutorial.csv", row.names = F, sep = ",")
# here we output the module eigengenes and trait y without eigengene significances
datTraits <- data.frame(ArrayName, datMEy)
dimnames(datTraits)[[2]][2:length(namesME)] <- paste("Trait",
  dimnames(datTraits)[[2]][2:length(namesME)],
  sep = "."
)
write.table(datTraits, file = "../examples/WGCNA/TraitsTutorial.csv", row.names = F, sep = ",")
rm(datTraits)
# here we output the simulated gene expression data
MicroarrayData <- data.frame(GeneName, t(datExpr))
names(MicroarrayData)[-1] <- ArrayName
write.table(MicroarrayData, file = "../examples/WGCNA/MicroarrayDataTutorial.csv", row.names = F, sep = ",")
rm(MicroarrayData)
```

```r
# Perform network screening
NS1GS <- networkScreeningGS(datExpr = datExpr, datME = datME, GS = GS1)
# Organize its results for easier plotting
GSprediction1 <- data.frame(GS1, NS1GS$GS.Weighted)
GS.Weighted <- NS1GS$GS.Weighted
# Plot a comparison between standard gene significance and network-weighted gene significance
sizeGrWindow(8, 6)
par(mfrow = c(1, 1))
verboseScatterplot(GS1, GS.Weighted,
  main = "Weighted gene significance vs. the standard GS\n",
  col = truemodule
)
abline(0, 1)
```

```r
EvaluationGeneScreeningGS <- corPredictionSuccess(
  corPrediction = GSprediction1, corTestSet = GS2,
  topNumber = seq(from = 20, to = 500, length = 30)
)
sizeGrWindow(8, 6)
par(mfrow = c(2, 2))
listcomp <- EvaluationGeneScreeningGS$meancorTestSetOverall
matplot(
  x = listcomp$topNumber,
  y = listcomp[, -1],
  main = "Predicting positive and negative correlations",
  ylab = "mean cor, test data",
  xlab = "top number of genes in the training data"
)
listcomp <- EvaluationGeneScreeningGS$meancorTestSetPositive
matplot(
  x = listcomp$topNumber,
  y = listcomp[, -1],
  main = "Predicting positive correlations",
  ylab = "mean cor, test data",
  xlab = "top number of genes in the training data"
)
listcomp <- EvaluationGeneScreeningGS$meancorTestSetNegative
matplot(
  x = listcomp$topNumber,
  y = listcomp[, -1],
  main = "Predicting negative correlations",
  ylab = "mean cor, test data",
  xlab = "top number of genes in the training data"
)
```

```r
collectGarbage()
save.image("../examples/WGCNA/Simulated-Screening.RData")
```

## 基因网络可视化

```r
rm(list = ls())
# Load the previously saved data
load("../examples/WGCNA/Simulated-RelatingToExt.RData")
load("../examples/WGCNA/Simulated-Screening.RData")
```

```r
cmd1 <- cmdscale(as.dist(dissTOM), 2)
sizeGrWindow(7, 6)
par(mfrow = c(1, 1))
plot(cmd1,
  col = as.character(colorh1), main = "MDS plot",
  xlab = "Scaling Dimension 1", ylab = "Scaling Dimension 2"
)
```

```r
power <- 6
color1 <- colorDynamicTOM
restGenes <- (color1 != "grey")
diss1 <- 1 - TOMsimilarityFromExpr(datExpr[, restGenes], power = 6)
hier1 <- hclust(as.dist(diss1), method = "average")
diag(diss1) <- NA
sizeGrWindow(7, 7)
TOMplot(diss1^4, hier1, as.character(color1[restGenes]),
  main = "TOM heatmap plot, module genes"
)
```

```r
power <- 6
color1 <- colorDynamicTOM
restGenes <- (color1 != "grey")
diss1 <- 1 - adjacency(datExpr[, restGenes], power = 6)
hier1 <- hclust(as.dist(diss1), method = "average")
diag(diss1) <- NA
sizeGrWindow(7, 7)
TOMplot(diss1^4, hier1, as.character(color1[restGenes]),
  main = "Adjacency heatmap plot, module genes"
)
```

```r
sizeGrWindow(7, 7)
topList <- rank(NS1$p.Weighted, ties.method = "first") <= 30
gene.names <- names(datExpr)[topList]
# The following shows the correlations between the top genes
plotNetworkHeatmap(datExpr,
  plotGenes = gene.names,
  networkType = "signed", useTOM = FALSE,
  power = 1, main = "signed correlations"
)
```

```r
sizeGrWindow(7, 7)
# The following shows the correlations between the top genes
plotNetworkHeatmap(datExpr,
  plotGenes = gene.names,
  networkType = "unsigned", useTOM = FALSE,
  power = 1, main = "signed correlations"
)
```

```r
sizeGrWindow(7, 7)
# The following shows the TOM heatmap in a signed network
plotNetworkHeatmap(datExpr,
  plotGenes = gene.names,
  networkType = "signed", useTOM = TRUE,
  power = 12, main = "C. TOM in a signed network"
)
# The following shows the TOM heatmap in a unsigned network
plotNetworkHeatmap(datExpr,
  plotGenes = gene.names,
  networkType = "unsigned", useTOM = TRUE,
  power = 6, main = "D. TOM in an unsigned network"
)
```

# 多个数据集的Meta分析

``` r
install.packages(c("impute","dynamicTreeCut","qvalue","flashClust","Hmisc"))
```

## 加载数据

```r
rm(list = ls())
load("../examples/metaAnalysisData.RData")
```

## 数据预处理

```r
source("../examples/collapseRows_NEW.R") # ONLY uncomment this line if you get an error with it commented
datExprB1g <- (collapseRows(datExprB1, genesI, probesI))[[1]]
datExprB2g <- (collapseRows(datExprB2, genesA, probesA))[[1]]
```

```r
commonProbesA <- intersect(rownames(datExprA1), rownames(datExprA2))
datExprA1p <- datExprA1[commonProbesA, ]
datExprA2p <- datExprA2[commonProbesA, ]
commonGenesB <- intersect(rownames(datExprB1g), rownames(datExprB2g))
datExprB1g <- datExprB1g[commonGenesB, ]
datExprB2g <- datExprB2g[commonGenesB, ]
```

## 相关网络特征

```r
softPower <- 10 # (Read WGCNA tutorial to learn how to pick your power)
rankExprA1 <- rank(rowMeans(datExprA1p))
rankExprA2 <- rank(rowMeans(datExprA2p))
random5000 <- sample(commonProbesA, 5000)
rankConnA1 <- rank(softConnectivity(t(datExprA1p[random5000, ]), type = "signed", power = softPower))
rankConnA2 <- rank(softConnectivity(t(datExprA2p[random5000, ]), type = "signed", power = softPower))
rankExprB1 <- rank(rowMeans(datExprB1g))
rankExprB2 <- rank(rowMeans(datExprB2g))
random5000 <- sample(commonGenesB, 5000)
rankConnB1 <- rank(softConnectivity(t(datExprB1g[random5000, ]), type = "signed", power = softPower))
rankConnB2 <- rank(softConnectivity(t(datExprB2g[random5000, ]), type = "signed", power = softPower))
# pdf("generalNetworkProperties.pdf", height=10, width=9)
par(mfrow = c(2, 2))
verboseScatterplot(rankExprA1, rankExprA2,
  xlab = "Ranked Expression (A1)",
  ylab = "Ranked Expression (A2)"
)
verboseScatterplot(rankConnA1, rankConnA2,
  xlab = "Ranked Connectivity (A1)",
  ylab = "Ranked Connectivity (A2)"
)
verboseScatterplot(rankExprB1, rankExprB2,
  xlab = "Ranked Expression (B1)",
  ylab = "Ranked Expression (B2)"
)
verboseScatterplot(rankConnB1, rankConnB2,
  xlab = "Ranked Connectivity (B1)",
  ylab = "Ranked Connectivity (B2)"
)
# dev.off()
```

## 运行WGCNA

```r
keepGenesExpr <- rank(-rowMeans(datExprA1p)) <= 5000
datExprA1g <- datExprA1p[keepGenesExpr, ]
datExprA2g <- datExprA2p[keepGenesExpr, ]
keepGenesDups <- (collapseRows(datExprA1g, genesI, probesI))[[2]]
datExprA1g <- datExprA1g[keepGenesDups[, 2], ]
datExprA2g <- datExprA2g[keepGenesDups[, 2], ]
rownames(datExprA1g) <- rownames(datExprA2g) <- keepGenesDups[, 1]
```

```r
adjacencyA1 <- adjacency(t(datExprA1g), power = softPower, type = "signed")
diag(adjacencyA1) <- 0
dissTOMA1 <- 1 - TOMsimilarity(adjacencyA1, TOMType = "signed")

geneTreeA1 <- flashClust(as.dist(dissTOMA1), method = "average")
adjacencyA2 <- adjacency(t(datExprA2g), power = softPower, type = "signed")
diag(adjacencyA2) <- 0
dissTOMA2 <- 1 - TOMsimilarity(adjacencyA2, TOMType = "signed")
geneTreeA2 <- flashClust(as.dist(dissTOMA2), method = "average")
save.image("../examples/WGCNA/tutorial.RData")
```

```r
load("../examples/WGCNA/tutorial.RData")
# pdf("dendrogram.pdf",height=6,width=16)
par(mfrow = c(1, 2))
plot(geneTreeA1,
  xlab = "", sub = "", main = "Gene clustering on TOM-based dissimilarity (A1)",
  labels = FALSE, hang = 0.04
)
plot(geneTreeA2,
  xlab = "", sub = "", main = "Gene clustering on TOM-based dissimilarity (A2)",
  labels = FALSE, hang = 0.04
)
# dev.off()
```

```r
mColorh <- NULL
for (ds in 0:3) {
  tree <- cutreeHybrid(
    dendro = geneTreeA1, pamStage = FALSE,
    minClusterSize = (30 - 3 * ds), cutHeight = 0.99,
    deepSplit = ds, distM = dissTOMA1
  )
  mColorh <- cbind(mColorh, labels2colors(tree$labels))
}
# pdf("Module_choices.pdf", height=10,width=25);
plotDendroAndColors(geneTreeA1, mColorh, paste("dpSplt =", 0:3), main = "", dendroLabels = FALSE)
# dev.off()
modulesA1 <- mColorh[, 1] # (Chosen based on plot below)
```

```r
PCs1A <- moduleEigengenes(t(datExprA1g), colors = modulesA1)
ME_1A <- PCs1A$eigengenes
distPC1A <- 1 - abs(cor(ME_1A, use = "p"))
distPC1A <- ifelse(is.na(distPC1A), 0, distPC1A)
pcTree1A <- hclust(as.dist(distPC1A), method = "a")
MDS_1A <- cmdscale(as.dist(distPC1A), 2)
colorsA1 <- names(table(modulesA1))
save.image("../examples/WGCNA/tutorial.RData")
# pdf("ModuleEigengeneVisualizations.pdf",height=6,width=6)
par(mfrow = c(1, 1), mar = c(0, 3, 1, 1) + 0.1, cex = 1)
plot(pcTree1A, xlab = "", ylab = "", main = "", sub = "")
plot(MDS_1A, col = colorsA1, main = "MDS plot", cex = 2, pch = 19)
ordergenes <- geneTreeA1$order
plotMat(scale(log(datExprA1g[ordergenes, ])),
  rlabels = modulesA1[ordergenes], clabels =
    colnames(datExprA1g), rcols = modulesA1[ordergenes]
)
for (which.module in names(table(modulesA1))) {
  ME <- ME_1A[, paste("ME", which.module, sep = "")]
  barplot(ME,
    col = which.module, main = "", cex.main = 2,
    ylab = "eigengene expression", xlab = "array sample"
  )
}
# dev.off()
```

## 在模块水平上分析网络

```r
# pdf("Final_modules.pdf",height=8,width=12)
plotDendroAndColors(geneTreeA1, modulesA1, "Modules",
  dendroLabels = FALSE, hang = 0.03, addGuide = TRUE,
  guideHang = 0.05, main = "Gene dendrogram and module colors (A1)"
)
plotDendroAndColors(geneTreeA2, modulesA1, "Modules",
  dendroLabels = FALSE, hang = 0.03, addGuide = TRUE,
  guideHang = 0.05, main = "Gene dendrogram and module colors (A2)"
)
# dev.off()
```

```r
# (This step will take ~10-30 minutes)
multiExpr <- list(A1 = list(data = t(datExprA1g)), A2 = list(data = t(datExprA2g)))
multiColor <- list(A1 = modulesA1)
mp <- modulePreservation(multiExpr, multiColor,
  referenceNetworks = 1, verbose = 3, networkType = "signed",
  nPermutations = 30, maxGoldModuleSize = 100, maxModuleSize = 400
)
stats <- mp$preservation$Z$ref.A1$inColumnsAlsoPresentIn.A2
stats[order(-stats[, 2]), c(1:2)]
```

## 模块成员（kME）在网络中的比较

```r
geneModuleMembership1 <- signedKME(t(datExprA1g), ME_1A)
colnames(geneModuleMembership1) <- paste("PC", colorsA1, ".cor", sep = "")
MMPvalue1 <- corPvalueStudent(as.matrix(geneModuleMembership1), dim(datExprA1g)[[2]])
colnames(MMPvalue1) <- paste("PC", colorsA1, ".pval", sep = "")
Gene <- rownames(datExprA1g)
kMEtable1 <- cbind(Gene, Gene, modulesA1)
for (i in 1:length(colorsA1)) {
  kMEtable1 <- cbind(kMEtable1, geneModuleMembership1[, i], MMPvalue1[, i])
}
colnames(kMEtable1) <- c("PSID", "Gene", "Module", sort(c(
  colnames(geneModuleMembership1),
  colnames(MMPvalue1)
)))
write.csv(kMEtable1, "../examples/WGCNA/kMEtable1.csv", row.names = FALSE)
```

```r
# First calculate MEs for A2, since we haven't done that yet
PCs2A <- moduleEigengenes(t(datExprA2g), colors = modulesA1)
ME_2A <- PCs2A$eigengenes
geneModuleMembership2 <- signedKME(t(datExprA2g), ME_2A)
colnames(geneModuleMembership1) <- paste("PC", colorsA1, ".cor", sep = "")
MMPvalue2 <- corPvalueStudent(as.matrix(geneModuleMembership2), dim(datExprA2g)[[2]])
colnames(MMPvalue2) <- paste("PC", colorsA1, ".pval", sep = "")
kMEtable2 <- cbind(Gene, Gene, modulesA1)
for (i in 1:length(colorsA1)) {
  kMEtable2 <- cbind(kMEtable2, geneModuleMembership2[, i], MMPvalue2[, i])
}
colnames(kMEtable2) <- colnames(kMEtable1)
write.csv(kMEtable2, "../examples/WGCNA/kMEtable2.csv", row.names = FALSE)
```

```r
# pdf("all_kMEtable2_vs_kMEtable1.pdf",height=8,width=8)
for (c in 1:length(colorsA1)) {
  verboseScatterplot(geneModuleMembership2[, c], geneModuleMembership1[, c],
    main = colorsA1[c],
    xlab = "kME in A2", ylab = "kME in A1"
  )
}
# dev.off()
# pdf("inModule_kMEtable2_vs_kMEtable1.pdf",height=8,width=8)
for (c in 1:length(colorsA1)) {
  inMod <- modulesA1 == colorsA1[c]
  verboseScatterplot(geneModuleMembership2[inMod, c], geneModuleMembership1[inMod, c],
    main = colorsA1[c],
    xlab = "kME in A2", ylab = "kME in A1"
  )
}
# dev.off()
save.image("../examples/WGCNA/tutorial.RData") # (optional line of code)
```

```r
topGenesKME <- NULL
for (c in 1:length(colorsA1)) {
  kMErank1 <- rank(-geneModuleMembership1[, c])
  kMErank2 <- rank(-geneModuleMembership2[, c])
  maxKMErank <- rank(apply(cbind(kMErank1, kMErank2 + .00001), 1, max))
  topGenesKME <- cbind(topGenesKME, Gene[maxKMErank <= 10])
}
colnames(topGenesKME) <- colorsA1
topGenesKME
```

## 使用外部程序比较网络并注释模块

```r
source("../examples/tutorialFunctions.R")
oldwd <- getwd()
setwd("../examples/WGCNA/")
for (co in colorsA1[colorsA1 != "grey"]) {
  visantPrepOverall(modulesA1, co, t(datExprA1g), rownames(datExprA1g), 500, softPower, TRUE)
}
setwd(oldwd)
```

```r
oldwd <- getwd()
setwd("../examples/WGCNA/")
for (co in colorsA1[colorsA1 != "grey"]) {
  visantPrepOverall(modulesA1, co, t(datExprA2g), rownames(datExprA2g), 500, softPower, TRUE)
}
setwd(oldwd)
```

```r
oldwd <- getwd()
setwd("../examples/WGCNA/")
datExprA12g <- t(cbind(datExprA1g, datExprA2g))
i1 <- 1:dim(datExprA1g)[[2]]
i2 <- (1:dim(datExprA2g)[[2]]) + length(i1)
for (co in colorsA1[colorsA1 != "grey"]) {
  visantPrep(modulesA1, co, i1, i2, datExprA12g, rownames(datExprA1g), 500, softPower, TRUE)
}
setwd(oldwd)
```

```r
folder <- "../examples/WGCNA/geneLists_A12/"
if (!dir.exists(folder)) dir.create(folder)
for (c in colorsA1) {
  fn <- paste(folder, c, ".txt", sep = "")
  write.geneList(Gene[modulesA1 == c], fn)
}
write(Gene, paste(folder, "all.txt", sep = ""))
```

```r
enrichments <- userListEnrichment(
  Gene, modulesA1, c("../examples/exampleListInput.csv", "../examples/exampleMMInput.csv"),
  c("cellType", "humanModules"), "../examples/WGCNA/enrichment.csv"
)
```

```r
enrichments$ovGenes$"green -- cellType_Astrocyte_Cahoy_all"
```

## 使用表型信息确定差异表达基因和模块

```r
region <- rep("CA1", 32)
region[c(1, 4, 6, 11, 12, 15, 16, 17, 22, 24, 25, 26, 28, 29, 31, 32)] <- "CA3"
age <- c(
  81, 72, 86, 90, 88, 90, 90, 74, 83, 73, 73, 70, 85, 85, 75, 90, 72, 70, 90, 84, 75, 85, 80,
  86, 85, 84, 81, 88, 80, 90, 83, 74
)
```

```r
# Find the top 3 region genes
var <- list(region == "CA1", region == "CA3")
datReg <- t(apply(datExprA1g, 1, t.test.l))
colnames(datReg) <- c("MeanCA1", "MeanCA3", "SD_CA1", "SD_CA3", "PvalRegion")
datReg[order(datReg[, 5])[1:3], ]
```

```r
# Find the top 3 age genes
var <- age
datAge <- t(apply(datExprA1g, 1, cor.test.l))
colnames(datAge) <- c("CorrAge", "PvalAge")
datAge[order(datAge[, 2])[1:3], ]
```

```r
# Find the region-related modules
var <- list(region == "CA1", region == "CA3")
datRegM <- t(apply(t(ME_1A), 1, t.test.l))
colnames(datRegM) <- c("MeanCA1", "MeanCA3", "SD_CA1", "SD_CA3", "PvalRegion")
datRegM[datRegM[, 5] < 0.02, ]
```

```r
# Find the age-related modules
var <- age
datAgeM <- t(apply(t(ME_1A), 1, cor.test.l))
colnames(datAgeM) <- c("CorrAge", "PvalAge")
datAgeM[datAgeM[, 2] < 0.02, ]
```

```r
# pdf("RegionAgePlots.pdf",width=16,height=4)
par(mfrow = c(1, 4))
verboseBoxplot(as.numeric(datExprA1g["NRIP3", ]), region,
  main = "NRIP3 expression -", las = 2, xlab = "Region", ylab = ""
)
verboseScatterplot(age, as.numeric(datExprA1g["DDX42", ]),
  main = "DDX42 expression -", las = 2, abline = TRUE, xlab = "Age", ylab = ""
)
verboseBoxplot(as.numeric(ME_1A[, "MEgreen"]), region,
  main = "Green ME expr. -", las = 2, xlab = "Region", ylab = ""
)
verboseScatterplot(age, as.numeric(ME_1A[, "MEmagenta"]),
  main = "Magenta ME expr. -", las = 2, abline = TRUE, xlab = "Age", ylab = ""
)
# dev.off()
```

```r
region2 <- rep("CA1", 31)
region2[c(1, 4, 7, 8, 9, 11, 15, 18, 20, 21, 22, 26, 28, 29, 30)] <- "CA3"
var <- list(region2 == "CA1", region2 == "CA3")
datReg2 <- t(apply(datExprA2g, 1, t.test.l))
colnames(datReg2) <- c("MeanCA1", "MeanCA3", "SD_CA1", "SD_CA3", "PvalRegion")
datRegM2 <- t(apply(t(ME_2A), 1, t.test.l))
colnames(datRegM2) <- c("MeanCA1", "MeanCA3", "SD_CA1", "SD_CA3", "PvalRegion")
# pdf("RegionAgePlots12.pdf",width=16,height=4)
par(mfrow = c(1, 4))
verboseBoxplot(as.numeric(datExprA1g["NRIP3", ]), region,
  main = "NRIP3 expression (A1) -", las = 2, xlab = "Region (A1)", ylab = ""
)
verboseBoxplot(as.numeric(datExprA2g["NRIP3", ]), region2,
  main = "NRIP3 expression (A2) -", las = 2, xlab = "Region (A2)", ylab = ""
)
verboseBoxplot(as.numeric(ME_1A[, "MEgreen"]), region,
  main = "Green ME expr. (A1) -", las = 2, xlab = "Region (A1)", ylab = ""
)
verboseBoxplot(as.numeric(ME_2A[, "MEgreen"]), region2,
  main = "Green ME expr. (A2) -", las = 2, xlab = "Region (A2)", ylab = ""
)
# dev.off()
```

## 比较不同的网络模块

```r
# (This section will take 5-15 minutes to run)
datExprB2g <- (collapseRows(datExprB2, genesA, probesA))[[1]]
GeneAB <- sort(intersect(rownames(datExprB2g), Gene)) # There are 3396 genes in this network
datExprB2g <- datExprB2g[GeneAB, ]
adjacencyB2 <- adjacency(t(datExprB2g), power = softPower, type = "signed")
diag(adjacencyB2) <- 0
dissTOMB2 <- 1 - TOMsimilarity(adjacencyB2, TOMType = "signed")
geneTreeB2 <- flashClust(as.dist(dissTOMB2), method = "average")
mColorh <- NULL
for (ds in 0:3) {
  tree <- cutreeHybrid(
    dendro = geneTreeB2, pamStage = FALSE, minClusterSize = (30 - 3 * ds),
    cutHeight = 0.99, deepSplit = ds, distM = dissTOMB2
  )
  mColorh <- cbind(mColorh, labels2colors(tree$labels))
}
# pdf("Module_choices_B2.pdf", height=10,width=25);
plotDendroAndColors(geneTreeB2, mColorh, paste("dpSplt =", 0:3), main = "", dendroLabels = FALSE)
# dev.off()
modulesB2 <- mColorh[, 1] # (Deepsplit=0 Chosen based on plot below)
colorsB2 <- names(table(modulesB2))
```

```r
modulesB2_new <- matchModules(Gene, modulesA1, GeneAB, modulesB2)
enrichmentsB2A1 <- userListEnrichment(GeneAB, modulesB2, "../examples/WGCNA/kMEtable1.csv", "A1", "../examples/WGCNA/enrichmentB2_A1.csv")
enrichmentsB2A1$sigOverlaps # To show the significant overlaps on the screen
```

```r
# pdf("A1_B2_dendrogram_plots.pdf",height=5,width=15)
plotDendroAndColors(geneTreeA1, modulesA1, "A1",
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05, main = "A1 dendrogram"
)
plotDendroAndColors(geneTreeB2, modulesB2_new, "B2_new",
  dendroLabels = FALSE, hang = 0.03,
  addGuide = TRUE, guideHang = 0.05, main = "B2 dendrogram"
)
# dev.off()
```
